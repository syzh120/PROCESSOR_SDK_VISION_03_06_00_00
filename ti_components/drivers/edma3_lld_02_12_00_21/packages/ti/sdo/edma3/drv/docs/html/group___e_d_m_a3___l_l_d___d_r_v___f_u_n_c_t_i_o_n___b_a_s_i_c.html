<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>EDMA3 Driver: EDMA3 Driver Basic APIs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>EDMA3 Driver Basic APIs<br/>
<small>
[<a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n.html">EDMA3 Driver APIs</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___b_a_s_i_c.html#gaf972552f53ce9efe4db7bfe6db275c06">EDMA3_DRV_requestChannel</a> (EDMA3_DRV_Handle hEdma, uint32_t *pLCh, uint32_t *pTcc, EDMA3_RM_EventQueue evtQueue, EDMA3_RM_TccCallback tccCb, void *cbData)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Request a DMA/QDMA/Link channel.  <a href="#gaf972552f53ce9efe4db7bfe6db275c06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___b_a_s_i_c.html#ga9b9c0be3ecedbaef8a136a3a515b0a7a">EDMA3_DRV_freeChannel</a> (EDMA3_DRV_Handle hEdma, uint32_t channelId)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Free the specified channel (DMA/QDMA/Link) and its associated resources (PaRAM Set, TCC etc) and removes various mappings.  <a href="#ga9b9c0be3ecedbaef8a136a3a515b0a7a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___b_a_s_i_c.html#ga3a43d634119deb804bf214c54d6be3d8">EDMA3_DRV_clearErrorBits</a> (EDMA3_DRV_Handle hEdma, uint32_t channelId)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disables the DMA Channel by clearing the Event Enable Register and clears Error Register &amp; Secondary Event Register for a specific DMA channel.  <a href="#ga3a43d634119deb804bf214c54d6be3d8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___b_a_s_i_c.html#ga057f492e45940e2b7ba12b8d48d49e15">EDMA3_DRV_setOptField</a> (EDMA3_DRV_Handle hEdma, uint32_t lCh, <a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#gaa0c576e8e46ac8db85c05bf73c01a5f9">EDMA3_DRV_OptField</a> optField, uint32_t newOptFieldVal)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a particular OPT field in the PaRAM set associated with the logical channel 'lCh'.  <a href="#ga057f492e45940e2b7ba12b8d48d49e15"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___b_a_s_i_c.html#ga05d77b37318ef8e81868a28678a7b2ac">EDMA3_DRV_getOptField</a> (EDMA3_DRV_Handle hEdma, uint32_t lCh, <a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#gaa0c576e8e46ac8db85c05bf73c01a5f9">EDMA3_DRV_OptField</a> optField, uint32_t *optFieldVal)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a particular OPT field in the PaRAM set associated with the logical channel 'lCh'.  <a href="#ga05d77b37318ef8e81868a28678a7b2ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___b_a_s_i_c.html#ga89c3174bf68727a9bc653d38989449ad">EDMA3_DRV_setSrcParams</a> (EDMA3_DRV_Handle hEdma, uint32_t lCh, uint32_t srcAddr, <a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#ga5896f43e878f4e9c47b449fccdec3af9">EDMA3_DRV_AddrMode</a> addrMode, <a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#ga8c37673293432ed46f9e26f04f5681dc">EDMA3_DRV_FifoWidth</a> fifoWidth)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">DMA source parameters setup.  <a href="#ga89c3174bf68727a9bc653d38989449ad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___b_a_s_i_c.html#ga2a1ae983cef808737455677b7c2c0fb5">EDMA3_DRV_setDestParams</a> (EDMA3_DRV_Handle hEdma, uint32_t lCh, uint32_t destAddr, <a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#ga5896f43e878f4e9c47b449fccdec3af9">EDMA3_DRV_AddrMode</a> addrMode, <a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#ga8c37673293432ed46f9e26f04f5681dc">EDMA3_DRV_FifoWidth</a> fifoWidth)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">DMA Destination parameters setup.  <a href="#ga2a1ae983cef808737455677b7c2c0fb5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___b_a_s_i_c.html#gaa4f81e82c3c44391074ff86444080fa4">EDMA3_DRV_setSrcIndex</a> (EDMA3_DRV_Handle hEdma, uint32_t lCh, int32_t srcBIdx, int32_t srcCIdx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">DMA source index setup.  <a href="#gaa4f81e82c3c44391074ff86444080fa4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___b_a_s_i_c.html#ga743d009b49ca70a22c6f1fbec0683f82">EDMA3_DRV_setDestIndex</a> (EDMA3_DRV_Handle hEdma, uint32_t lCh, int32_t destBIdx, int32_t destCIdx)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">DMA destination index setup.  <a href="#ga743d009b49ca70a22c6f1fbec0683f82"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___b_a_s_i_c.html#ga44ba1ae06ac1a6aba94bd3f86f8e4f2e">EDMA3_DRV_setTransferParams</a> (EDMA3_DRV_Handle hEdma, uint32_t lCh, uint32_t aCnt, uint32_t bCnt, uint32_t cCnt, uint32_t bCntReload, <a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#ga1cc0705e142298a424a312034bd3b2c2">EDMA3_DRV_SyncType</a> syncType)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">DMA transfer parameters setup.  <a href="#ga44ba1ae06ac1a6aba94bd3f86f8e4f2e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___b_a_s_i_c.html#ga421bbec32ba1335296de937e35acc215">EDMA3_DRV_getVersion</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Version information.  <a href="#ga421bbec32ba1335296de937e35acc215"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___b_a_s_i_c.html#ga43f6e71816afb2d823a73ee9f90b073b">EDMA3_DRV_getVersionStr</a> (void)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Version string querry.  <a href="#ga43f6e71816afb2d823a73ee9f90b073b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___b_a_s_i_c.html#ga058da475e4b2e6db3f745611bd26fb27">EDMA3_DRV_enableTransfer</a> (EDMA3_DRV_Handle hEdma, uint32_t lCh, <a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#ga9a3d4fdcf4d2d089d4defebe3ef3880e">EDMA3_DRV_TrigMode</a> trigMode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start EDMA transfer on the specified channel.  <a href="#ga058da475e4b2e6db3f745611bd26fb27"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___b_a_s_i_c.html#ga999444d7f079889ea8e1c825b8bdd05a">EDMA3_DRV_disableTransfer</a> (EDMA3_DRV_Handle hEdma, uint32_t lCh, <a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#ga9a3d4fdcf4d2d089d4defebe3ef3880e">EDMA3_DRV_TrigMode</a> trigMode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable DMA transfer on the specified channel.  <a href="#ga999444d7f079889ea8e1c825b8bdd05a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___b_a_s_i_c.html#gaeb4d5d16d283e5dda906cdac67a44d18">EDMA3_DRV_disableLogicalChannel</a> (EDMA3_DRV_Handle hEdma, uint32_t lCh, <a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#ga9a3d4fdcf4d2d089d4defebe3ef3880e">EDMA3_DRV_TrigMode</a> trigMode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable the event driven DMA channel or QDMA channel.  <a href="#gaeb4d5d16d283e5dda906cdac67a44d18"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaf972552f53ce9efe4db7bfe6db275c06"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_requestChannel" ref="gaf972552f53ce9efe4db7bfe6db275c06" args="(EDMA3_DRV_Handle hEdma, uint32_t *pLCh, uint32_t *pTcc, EDMA3_RM_EventQueue evtQueue, EDMA3_RM_TccCallback tccCb, void *cbData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_requestChannel </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>pLCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>pTcc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EDMA3_RM_EventQueue&nbsp;</td>
          <td class="paramname"> <em>evtQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EDMA3_RM_TccCallback&nbsp;</td>
          <td class="paramname"> <em>tccCb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cbData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request a DMA/QDMA/Link channel. </p>
<p>Each channel (DMA/QDMA/Link) must be requested before initiating a DMA transfer on that channel.</p>
<p>This API is used to allocate a logical channel (DMA/QDMA/Link) along with the associated resources. For DMA and QDMA channels, TCC and PaRAM Set are also allocated along with the requested channel. User can also specify a specific TCC which needs to be allocated with the DMA/QDMA channel or else can request any available TCC.</p>
<p>For Link channels, ONLY a PaRAM Set is allocated and the allocated PaRAM Set number is returned as the logical channel no. A TCC code can also be specified while making the request. This TCC code will be copied to the LINK field of the allocated PaRAM Set and will be associated with the Link channel.</p>
<p>User can request a specific logical channel - DMA, QDMA and Link, by passing the channel id in 'pLCh'. Note that the channel id is the same as the actual resource id in case of DMA channels and Link channels. For DMA channels, channel id lies between 0 and (max dma channels - 1). For Link channels, channel id lies between (max dma channels) and (max param sets - 1). To allocate specific QDMA channels, user SHOULD use the defines EDMA3_DRV_QDMA_CHANNEL_X mentioned above.</p>
<p>User can also request ANY available logical channel by specifying the below mentioned values in '*pLCh': a) EDMA3_DRV_DMA_CHANNEL_ANY: For DMA channels b) EDMA3_DRV_QDMA_CHANNEL_ANY: For QDMA channels, and c) EDMA3_DRV_LINK_CHANNEL: For Link channels. Normally user should use this value to request link channels (PaRAM Sets used for linking purpose only), unless he wants to use some specific link channels (PaRAM Sets) which is also allowed. d) EDMA3_DRV_LINK_CHANNEL_WITH_TCC: For Link channels. User should use this value to request link channels with TCC code.</p>
<p>This API internally uses EDMA3_RM_allocResource () to allocate the desired resources (DMA/QDMA channel, PaRAM Set and TCC).</p>
<p>This API also registers a specific callback function, in case the same is provided, against the allocated TCC. To do this, this API calls EDMA3_RM_registerTccCb(), which is a part of the Resource Manager. Please note that the interrupts are enabled for the specific TCC only if callback function is provided. In the absence of this, the API assumes that the requested logical channel is going to be used in Poll mode environment.</p>
<p>For DMA/QDMA channels, after allocating all the EDMA3 resources, this API sets the TCC field of the OPT PaRAM Word with the allocated TCC. It also sets the event queue for the channel allocated. The event queue needs to be specified by the user.</p>
<p>For DMA channel, it also sets the DCHMAP register, if required.</p>
<p>For QDMA channel, it sets the QCHMAP register and CCNT as trigger word and enables the QDMA channel by writing to the QEESR register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the previously opened Driver Instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pLCh</em>&nbsp;</td><td>[IN/OUT] Requested logical channel id. Examples:</p>
<ul>
<li>EDMA3_DRV_HW_CHANNEL_EVENT_0</li>
<li>To request a DMA Master Channel mapped to EDMA Event 0.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>EDMA3_DRV_DMA_CHANNEL_ANY</li>
<li>For requesting any DMA Master channel with no event mapping.</li>
</ul>
<ul>
<li>EDMA3_DRV_QDMA_CHANNEL_ANY</li>
<li>For requesting any QDMA Master channel</li>
</ul>
<ul>
<li>EDMA3_DRV_QDMA_CHANNEL_0</li>
<li>For requesting the QDMA Channel 0.</li>
</ul>
<ul>
<li>EDMA3_DRV_LINK_CHANNEL</li>
<li>For requesting a DMA Slave Channel,</li>
<li>to be linked to some other Master</li>
<li>channel.</li>
</ul>
<ul>
<li>EDMA3_DRV_LINK_CHANNEL_WITH_TCC</li>
<li>For requesting a DMA Slave Channel,</li>
<li>to be linked to some other Master</li>
<li>channel, with a TCC associated with it.</li>
</ul>
<p>In case user passes a specific channel Id, pLCh value is left unchanged. In case user requests ANY available resource, the allocated channel id is returned in pLCh.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>To request a PaRAM Set for the purpose of linking to another channel, call the function with</dd></dl>
<p>*pLCh = EDMA3_DRV_LINK_CHANNEL or EDMA3_DRV_LINK_CHANNEL_WITH_TCC</p>
<p>This function will update *pLCh with the allocated Link channel handle.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pTcc</em>&nbsp;</td><td>[IN/OUT] The channel number on which the completion/error interrupt is generated. Not used if user requested for a Link channel. Examples:</p>
<ul>
<li>EDMA3_DRV_HW_CHANNEL_EVENT_0</li>
<li>To request TCC associated with</li>
<li>DMA Master Channel mapped to EDMA</li>
<li>event 0.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>EDMA3_DRV_TCC_ANY</li>
<li>For requesting any TCC with no</li>
<li>channel mapping. In case user passes a specific TCC value, pTcc value is left unchanged. In case user requests ANY available TCC, the allocated one is returned in pTcc</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>evtQueue</em>&nbsp;</td><td>[IN] Event Queue Number to which the channel will be mapped (valid only for the Master Channel (DMA/QDMA) request)</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tccCb</em>&nbsp;</td><td>[IN] TCC callback - caters to channel- specific events like "Event Miss Error" or "Transfer Complete"</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbData</em>&nbsp;</td><td>[IN] Data which will be passed directly to the tccCb callback function</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function internally uses EDMA3 Resource Manager, which acquires a RM Instance specific semaphore to prevent simultaneous access to the global pool of resources. It also disables the global interrupts while modifying the global CC registers. It is re-entrant, but SHOULD NOT be called from the user callback function (ISR context). </dd></dl>

</div>
</div>
<a class="anchor" id="ga9b9c0be3ecedbaef8a136a3a515b0a7a"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_freeChannel" ref="ga9b9c0be3ecedbaef8a136a3a515b0a7a" args="(EDMA3_DRV_Handle hEdma, uint32_t channelId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_freeChannel </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>channelId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Free the specified channel (DMA/QDMA/Link) and its associated resources (PaRAM Set, TCC etc) and removes various mappings. </p>
<p>This API internally uses EDMA3_RM_freeResource () to free the desired resources.</p>
<p>For Link channels, this API only frees the associated PaRAM Set.</p>
<p>For DMA/QDMA channels, it does the following operations: a) Disable any ongoing transfer on the channel, b) Unregister the TCC Callback function and disable the interrupts, c) Remove the channel to Event Queue mapping, d) For DMA channels, clear the DCHMAP register, if available e) For QDMA channels, clear the QCHMAP register, f) Frees the DMA/QDMA channel in the end.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channelId</em>&nbsp;</td><td>[IN] Logical Channel number to be freed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function disables the global interrupts while modifying the global CC registers and while modifying global data structures, to prevent simultaneous access to the global pool of resources. It internally calls EDMA3_RM_freeResource () for resource de-allocation. It is re-entrant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3a43d634119deb804bf214c54d6be3d8"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_clearErrorBits" ref="ga3a43d634119deb804bf214c54d6be3d8" args="(EDMA3_DRV_Handle hEdma, uint32_t channelId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_clearErrorBits </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>channelId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disables the DMA Channel by clearing the Event Enable Register and clears Error Register &amp; Secondary Event Register for a specific DMA channel. </p>
<p>This API clears the Event Enable register, Event Miss register and Secondary Event register for a specific DMA channel. It also clears the CC Error register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channelId</em>&nbsp;</td><td>[IN] DMA Channel needs to be cleaned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for unique channelId values. It is non- re-entrant for same channelId value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga057f492e45940e2b7ba12b8d48d49e15"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_setOptField" ref="ga057f492e45940e2b7ba12b8d48d49e15" args="(EDMA3_DRV_Handle hEdma, uint32_t lCh, EDMA3_DRV_OptField optField, uint32_t newOptFieldVal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_setOptField </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#gaa0c576e8e46ac8db85c05bf73c01a5f9">EDMA3_DRV_OptField</a>&nbsp;</td>
          <td class="paramname"> <em>optField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>newOptFieldVal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a particular OPT field in the PaRAM set associated with the logical channel 'lCh'. </p>
<p>This API can be used to set various optional parameters for an EDMA3 transfer. Like enable/disable completion interrupts, enable/disable chaining, setting the transfer mode (A/AB Sync), setting the FIFO width etc.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lCh</em>&nbsp;</td><td>[IN] Logical Channel, bound to which PaRAM set OPT field needs to be set. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optField</em>&nbsp;</td><td>[IN] The particular field of OPT Word that needs setting </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newOptFieldVal</em>&nbsp;</td><td>[IN] The new OPT field value</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for unique lCh values. It is non- re-entrant for same lCh value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga05d77b37318ef8e81868a28678a7b2ac"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_getOptField" ref="ga05d77b37318ef8e81868a28678a7b2ac" args="(EDMA3_DRV_Handle hEdma, uint32_t lCh, EDMA3_DRV_OptField optField, uint32_t *optFieldVal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_getOptField </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#gaa0c576e8e46ac8db85c05bf73c01a5f9">EDMA3_DRV_OptField</a>&nbsp;</td>
          <td class="paramname"> <em>optField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>optFieldVal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a particular OPT field in the PaRAM set associated with the logical channel 'lCh'. </p>
<p>This API can be used to read various optional parameters for an EDMA3 transfer. Like enable/disable completion interrupts, enable/disable chaining, setting the transfer mode (A/AB Sync), setting the FIFO width etc.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lCh</em>&nbsp;</td><td>[IN] Logical Channel, bound to which PaRAM set OPT field is required. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optField</em>&nbsp;</td><td>[IN] The particular field of OPT Word that is needed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>optFieldVal</em>&nbsp;</td><td>[IN/OUT] Value of the OPT field</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga89c3174bf68727a9bc653d38989449ad"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_setSrcParams" ref="ga89c3174bf68727a9bc653d38989449ad" args="(EDMA3_DRV_Handle hEdma, uint32_t lCh, uint32_t srcAddr, EDMA3_DRV_AddrMode addrMode, EDMA3_DRV_FifoWidth fifoWidth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_setSrcParams </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>srcAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#ga5896f43e878f4e9c47b449fccdec3af9">EDMA3_DRV_AddrMode</a>&nbsp;</td>
          <td class="paramname"> <em>addrMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#ga8c37673293432ed46f9e26f04f5681dc">EDMA3_DRV_FifoWidth</a>&nbsp;</td>
          <td class="paramname"> <em>fifoWidth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DMA source parameters setup. </p>
<p>It is used to program the source address, source side addressing mode (INCR or FIFO) and the FIFO width in case the addressing mode is FIFO.</p>
<p>In FIFO Addressing mode, memory location must be 32 bytes aligned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lCh</em>&nbsp;</td><td>[IN] Logical Channel for which the source parameters are to be configured </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcAddr</em>&nbsp;</td><td>[IN] Source address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addrMode</em>&nbsp;</td><td>[IN] Address mode [FIFO or Increment] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fifoWidth</em>&nbsp;</td><td>[IN] Width of FIFO (Valid only if addrMode is FIFO)</p>
<ol type="1">
<li>0 - 8 bit</li>
<li>1 - 16 bit</li>
<li>2 - 32 bit</li>
<li>3 - 64 bit</li>
<li>4 - 128 bit</li>
<li>5 - 256 bit</li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for unique lCh values. It is non- re-entrant for same lCh value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2a1ae983cef808737455677b7c2c0fb5"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_setDestParams" ref="ga2a1ae983cef808737455677b7c2c0fb5" args="(EDMA3_DRV_Handle hEdma, uint32_t lCh, uint32_t destAddr, EDMA3_DRV_AddrMode addrMode, EDMA3_DRV_FifoWidth fifoWidth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_setDestParams </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>destAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#ga5896f43e878f4e9c47b449fccdec3af9">EDMA3_DRV_AddrMode</a>&nbsp;</td>
          <td class="paramname"> <em>addrMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#ga8c37673293432ed46f9e26f04f5681dc">EDMA3_DRV_FifoWidth</a>&nbsp;</td>
          <td class="paramname"> <em>fifoWidth</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DMA Destination parameters setup. </p>
<p>It is used to program the destination address, destination side addressing mode (INCR or FIFO) and the FIFO width in case the addressing mode is FIFO.</p>
<p>In FIFO Addressing mode, memory location must be 32 bytes aligned.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lCh</em>&nbsp;</td><td>[IN] Logical Channel for which the destination parameters are to be configured </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destAddr</em>&nbsp;</td><td>[IN] Destination address </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>addrMode</em>&nbsp;</td><td>[IN] Address mode [FIFO or Increment] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>fifoWidth</em>&nbsp;</td><td>[IN] Width of FIFO (Valid only if addrMode is FIFO)</p>
<ol type="1">
<li>0 - 8 bit</li>
<li>1 - 16 bit</li>
<li>2 - 32 bit</li>
<li>3 - 64 bit</li>
<li>4 - 128 bit</li>
<li>5 - 256 bit</li>
</ol>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for unique lCh values. It is non- re-entrant for same lCh value. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa4f81e82c3c44391074ff86444080fa4"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_setSrcIndex" ref="gaa4f81e82c3c44391074ff86444080fa4" args="(EDMA3_DRV_Handle hEdma, uint32_t lCh, int32_t srcBIdx, int32_t srcCIdx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_setSrcIndex </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>srcBIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>srcCIdx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DMA source index setup. </p>
<p>It is used to program the source B index and source C index.</p>
<p>SRCBIDX is a 16-bit signed value (2s complement) used for source address modification between each array in the 2nd dimension. Valid values for SRCBIDX are between -32768 and 32767. It provides a byte address offset from the beginning of the source array to the beginning of the next source array. It applies to both A-synchronized and AB-synchronized transfers.</p>
<p>SRCCIDX is a 16-bit signed value (2s complement) used for source address modification in the 3rd dimension. Valid values for SRCCIDX are between -32768 and 32767. It provides a byte address offset from the beginning of the current array (pointed to by SRC address) to the beginning of the first source array in the next frame. It applies to both A-synchronized and AB-synchronized transfers. Note that when SRCCIDX is applied, the current array in an A-synchronized transfer is the last array in the frame, while the current array in an AB-synchronized transfer is the first array in the frame.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lCh</em>&nbsp;</td><td>[IN] Logical Channel for which source indices are to be configured </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcBIdx</em>&nbsp;</td><td>[IN] Source B index </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>srcCIdx</em>&nbsp;</td><td>[IN] Source C index</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for unique lCh values. It is non- re-entrant for same lCh value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga743d009b49ca70a22c6f1fbec0683f82"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_setDestIndex" ref="ga743d009b49ca70a22c6f1fbec0683f82" args="(EDMA3_DRV_Handle hEdma, uint32_t lCh, int32_t destBIdx, int32_t destCIdx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_setDestIndex </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>destBIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>destCIdx</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DMA destination index setup. </p>
<p>It is used to program the destination B index and destination C index.</p>
<p>DSTBIDX is a 16-bit signed value (2s complement) used for destination address modification between each array in the 2nd dimension. Valid values for DSTBIDX are between -32768 and 32767. It provides a byte address offset from the beginning of the destination array to the beginning of the next destination array within the current frame. It applies to both A-synchronized and AB-synchronized transfers.</p>
<p>DSTCIDX is a 16-bit signed value (2s complement) used for destination address modification in the 3rd dimension. Valid values are between -32768 and 32767. It provides a byte address offset from the beginning of the current array (pointed to by DST address) to the beginning of the first destination array TR in the next frame. It applies to both A-synchronized and AB-synchronized transfers. Note that when DSTCIDX is applied, the current array in an A-synchronized transfer is the last array in the frame, while the current array in a AB-synchronized transfer is the first array in the frame</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lCh</em>&nbsp;</td><td>[IN] Logical Channel for which dest indices are to be configured </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destBIdx</em>&nbsp;</td><td>[IN] Destination B index </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destCIdx</em>&nbsp;</td><td>[IN] Destination C index</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for unique lCh values. It is non- re-entrant for same lCh value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga44ba1ae06ac1a6aba94bd3f86f8e4f2e"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_setTransferParams" ref="ga44ba1ae06ac1a6aba94bd3f86f8e4f2e" args="(EDMA3_DRV_Handle hEdma, uint32_t lCh, uint32_t aCnt, uint32_t bCnt, uint32_t cCnt, uint32_t bCntReload, EDMA3_DRV_SyncType syncType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_setTransferParams </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>aCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>bCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>cCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>bCntReload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#ga1cc0705e142298a424a312034bd3b2c2">EDMA3_DRV_SyncType</a>&nbsp;</td>
          <td class="paramname"> <em>syncType</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>DMA transfer parameters setup. </p>
<p>It is used to specify the various counts (ACNT, BCNT and CCNT), B count reload and the synchronization type</p>
<p>ACNT represents the number of bytes within the 1st dimension of a transfer. ACNT is a 16-bit unsigned value with valid values between 0 and 65535. Therefore, the maximum number of bytes in an array is 65535 bytes (64K - 1 bytes). ACNT must be greater than or equal to 1 for a TR to be submitted to EDMA3 Transfer Controller. An ACNT equal to 0 is considered either a null or dummy transfer. A dummy or null transfer generates a completion code depending on the settings of the completion bit fields in OPT.</p>
<p>BCNT is a 16-bit unsigned value that specifies the number of arrays of length ACNT. For normal operation, valid values for BCNT are between 1 and 65535. Therefore, the maximum number of arrays in a frame is 65535 (64K - 1 arrays). A BCNT equal to 0 is considered either a null or dummy transfer. A dummy or null transfer generates a completion code depending on the settings of the completion bit fields in OPT.</p>
<p>CCNT is a 16-bit unsigned value that specifies the number of frames in a block. Valid values for CCNT are between 1 and 65535. Therefore, the maximum number of frames in a block is 65535 (64K - 1 frames). A CCNT equal to 0 is considered either a null or dummy transfer. A dummy or null transfer generates a completion code depending on the settings of the completion bit fields in OPT. A CCNT value of 0 is considered either a null or dummy transfer.</p>
<p>BCNTRLD is a 16-bit unsigned value used to reload the BCNT field once the last array in the 2nd dimension is transferred. This field is only used for A-synchronized transfers. In this case, the EDMA3CC decrements the BCNT value by 1 on each TR submission. When BCNT (conceptually) reaches 0, the EDMA3CC decrements CCNT and uses the BCNTRLD value to reinitialize the BCNT value. For AB-synchronized transfers, the EDMA3CC submits the BCNT in the TR and the EDMA3TC decrements BCNT appropriately. For AB-synchronized transfers, BCNTRLD is not used.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lCh</em>&nbsp;</td><td>[IN] Logical Channel for which transfer parameters are to be configured </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>aCnt</em>&nbsp;</td><td>[IN] Count for 1st Dimension. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bCnt</em>&nbsp;</td><td>[IN] Count for 2nd Dimension. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cCnt</em>&nbsp;</td><td>[IN] Count for 3rd Dimension. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bCntReload</em>&nbsp;</td><td>[IN] Reload value for bCnt. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>syncType</em>&nbsp;</td><td>[IN] Transfer synchronization dimension 0: A-synchronized. Each event triggers the transfer of a single array of ACNT bytes. 1: AB-synchronized. Each event triggers the transfer of BCNT arrays of ACNT bytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for unique lCh values. It is non- re-entrant for same lCh value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga421bbec32ba1335296de937e35acc215"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_getVersion" ref="ga421bbec32ba1335296de937e35acc215" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t EDMA3_DRV_getVersion </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Version information. </p>
<p>The function is used to get the version information of the EDMA LLD.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Version Information. </dd></dl>

</div>
</div>
<a class="anchor" id="ga43f6e71816afb2d823a73ee9f90b073b"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_getVersionStr" ref="ga43f6e71816afb2d823a73ee9f90b073b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* EDMA3_DRV_getVersionStr </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Version string querry. </p>
<p>The function is used to get the version string for the EDMA LLD.</p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Version Information. </dd></dl>

</div>
</div>
<a class="anchor" id="ga058da475e4b2e6db3f745611bd26fb27"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_enableTransfer" ref="ga058da475e4b2e6db3f745611bd26fb27" args="(EDMA3_DRV_Handle hEdma, uint32_t lCh, EDMA3_DRV_TrigMode trigMode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_enableTransfer </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#ga9a3d4fdcf4d2d089d4defebe3ef3880e">EDMA3_DRV_TrigMode</a>&nbsp;</td>
          <td class="paramname"> <em>trigMode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Start EDMA transfer on the specified channel. </p>
<p>There are multiple ways to trigger an EDMA3 transfer. The triggering mode option allows choosing from the available triggering modes: Event, Manual or QDMA.</p>
<p>In event triggered, a peripheral or an externally generated event triggers the transfer. This API clears the Secondary Event Register and Event Miss Register and then enables the DMA channel by writing to the EESR.</p>
<p>In manual triggered mode, CPU manually triggers a transfer by writing a 1 in the Event Set Register (ESR/ESRH). This API writes to the ESR/ESRH to start the transfer.</p>
<p>In QDMA triggered mode, a QDMA transfer is triggered when a CPU (or other EDMA3 programmer) writes to the trigger word of the QDMA channel PaRAM set (auto-triggered) or when the EDMA3CC performs a link update on a PaRAM set that has been mapped to a QDMA channel (link triggered). This API enables the QDMA channel by writing to the QEESR register.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lCh</em>&nbsp;</td><td>[IN] Channel on which transfer has to be started </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>trigMode</em>&nbsp;</td><td>[IN] Mode of triggering start of transfer (Manual, QDMA or Event)</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for unique lCh values. It is non- re-entrant for same lCh value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga999444d7f079889ea8e1c825b8bdd05a"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_disableTransfer" ref="ga999444d7f079889ea8e1c825b8bdd05a" args="(EDMA3_DRV_Handle hEdma, uint32_t lCh, EDMA3_DRV_TrigMode trigMode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_disableTransfer </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#ga9a3d4fdcf4d2d089d4defebe3ef3880e">EDMA3_DRV_TrigMode</a>&nbsp;</td>
          <td class="paramname"> <em>trigMode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable DMA transfer on the specified channel. </p>
<p>There are multiple ways by which an EDMA3 transfer could be triggered. The triggering mode option allows choosing from the available triggering modes: Event, Manual or QDMA.</p>
<p>To disable a channel which was previously triggered in manual mode, this API clears the Secondary Event Register and Event Miss Register, if set, for the specific DMA channel.</p>
<p>To disable a channel which was previously triggered in QDMA mode, this API clears the QDMA Event Enable Register, for the specific QDMA channel.</p>
<p>To disable a channel which was previously triggered in event mode, this API clears the Event Enable Register. It also clears Event Register, Secondary Event Register and Event Miss Register, if set, for the specific DMA channel.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lCh</em>&nbsp;</td><td>[IN] Channel on which transfer has to be stopped </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>trigMode</em>&nbsp;</td><td>[IN] Mode of triggering start of transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for unique lCh values. It is non- re-entrant for same lCh value. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeb4d5d16d283e5dda906cdac67a44d18"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_disableLogicalChannel" ref="gaeb4d5d16d283e5dda906cdac67a44d18" args="(EDMA3_DRV_Handle hEdma, uint32_t lCh, EDMA3_DRV_TrigMode trigMode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_disableLogicalChannel </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#ga9a3d4fdcf4d2d089d4defebe3ef3880e">EDMA3_DRV_TrigMode</a>&nbsp;</td>
          <td class="paramname"> <em>trigMode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disable the event driven DMA channel or QDMA channel. </p>
<p>This API disables the DMA channel (which was previously triggered in event mode) by clearing the Event Enable Register; it disables the QDMA channel by clearing the QDMA Event Enable Register.</p>
<p>This API should NOT be used for DMA channels which are not mapped to any hardware events and are used for memory-to-memory copy based transfers. In case of that, this API returns error.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lCh</em>&nbsp;</td><td>[IN] DMA/QDMA Channel which needs to be disabled </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>trigMode</em>&nbsp;</td><td>[IN] Mode of triggering start of transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for unique lCh values. It is non- re-entrant for same lCh value. </dd></dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Mon Feb 14 18:34:00 2011 for EDMA3 Driver by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
