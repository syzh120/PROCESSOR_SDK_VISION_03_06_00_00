<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>EDMA3 Driver: EDMA3 Driver Advanced APIs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>EDMA3 Driver Advanced APIs<br/>
<small>
[<a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n.html">EDMA3 Driver APIs</a>]</small>
</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_e_d_m_a3___d_r_v___gbl_xbar_to_chan_config_params.html">EDMA3_DRV_GblXbarToChanConfigParams</a></td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Init-time Configuration structure for EDMA3 controller, to provide Global SoC specific Information.  <a href="struct_e_d_m_a3___d_r_v___gbl_xbar_to_chan_config_params.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef EDMA3_DRV_Result(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#gaba09a1e3f0dbc70cff309a0030776168">EDMA3_DRV_mapXbarEvtToChan</a> )(uint32_t eventNum, uint32_t *chanNum, const <a class="el" href="struct_e_d_m_a3___d_r_v___gbl_xbar_to_chan_config_params.html">EDMA3_DRV_GblXbarToChanConfigParams</a> *edmaGblXbarConfig)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Associates cross bar mapped event to channel.  <a href="#gaba09a1e3f0dbc70cff309a0030776168"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef EDMA3_DRV_Result(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga44bf9e6ccf89645f0fcd1c345d8b5fde">EDMA3_DRV_xbarConfigScr</a> )(uint32_t eventNum, uint32_t chanNum)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes to the cross bar mapped event to channel to system configuration register.  <a href="#ga44bf9e6ccf89645f0fcd1c345d8b5fde"></a><br/></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga5d0ac2830ede7245fc7a7b02666c4651">EDMA3_DRV_linkChannel</a> (EDMA3_DRV_Handle hEdma, uint32_t lCh1, uint32_t lCh2)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Link two logical channels.  <a href="#ga5d0ac2830ede7245fc7a7b02666c4651"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#gab385b2ade87dab8377a3116d5957b4b3">EDMA3_DRV_unlinkChannel</a> (EDMA3_DRV_Handle hEdma, uint32_t lCh)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlink the channel from the earlier linked logical channel.  <a href="#gab385b2ade87dab8377a3116d5957b4b3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga523dba0bb68b6a6762ee72d92bd4a003">EDMA3_DRV_chainChannel</a> (EDMA3_DRV_Handle hEdma, uint32_t lCh1, uint32_t lCh2, const <a class="el" href="struct_e_d_m_a3___d_r_v___chain_options.html">EDMA3_DRV_ChainOptions</a> *chainOptions)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Chain the two specified channels.  <a href="#ga523dba0bb68b6a6762ee72d92bd4a003"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#gaea1980b0debbfca7099beddc82613f30">EDMA3_DRV_unchainChannel</a> (EDMA3_DRV_Handle hEdma, uint32_t lCh)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unchain the two channels.  <a href="#gaea1980b0debbfca7099beddc82613f30"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga216c695659e783937361893e2954be67">EDMA3_DRV_setQdmaTrigWord</a> (EDMA3_DRV_Handle hEdma, uint32_t lCh, EDMA3_RM_QdmaTrigWord trigWord)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assign a Trigger Word to the specified QDMA channel.  <a href="#ga216c695659e783937361893e2954be67"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#gae701899e3ecaffde66019991cc075e06">EDMA3_DRV_setPaRAM</a> (EDMA3_DRV_Handle hEdma, uint32_t lCh, const <a class="el" href="struct_e_d_m_a3___d_r_v___pa_r_a_m_regs.html">EDMA3_DRV_PaRAMRegs</a> *newPaRAM)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy the user specified PaRAM Set onto the PaRAM Set associated with the logical channel (DMA/QDMA/Link).  <a href="#gae701899e3ecaffde66019991cc075e06"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#gab7a95585219b3140771a6c7e07dea1ee">EDMA3_DRV_getPaRAM</a> (EDMA3_DRV_Handle hEdma, uint32_t lCh, <a class="el" href="struct_e_d_m_a3___d_r_v___pa_r_a_m_regs.html">EDMA3_DRV_PaRAMRegs</a> *currPaRAM)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Retrieve existing PaRAM set associated with specified logical channel (DMA/QDMA/Link).  <a href="#gab7a95585219b3140771a6c7e07dea1ee"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga801246bc529343f0324d125c65537fe8">EDMA3_DRV_setPaRAMEntry</a> (EDMA3_DRV_Handle hEdma, uint32_t lCh, <a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#ga82b01ec2292a13ad48a5bfcc724dfac6">EDMA3_DRV_PaRAMEntry</a> paRAMEntry, uint32_t newPaRAMEntryVal)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a particular PaRAM set entry of the specified PaRAM set.  <a href="#ga801246bc529343f0324d125c65537fe8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#gad131a9d84d316d8c2c73c37ad8f6b520">EDMA3_DRV_getPaRAMEntry</a> (EDMA3_DRV_Handle hEdma, uint32_t lCh, <a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#ga82b01ec2292a13ad48a5bfcc724dfac6">EDMA3_DRV_PaRAMEntry</a> paRAMEntry, uint32_t *paRAMEntryVal)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a particular PaRAM set entry of the specified PaRAM set.  <a href="#gad131a9d84d316d8c2c73c37ad8f6b520"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga6b57b385ba8fca2757da48f714550f99">EDMA3_DRV_setPaRAMField</a> (EDMA3_DRV_Handle hEdma, uint32_t lCh, <a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#ga3e31ba1b02dcbace3044c11c83ef5466">EDMA3_DRV_PaRAMField</a> paRAMField, uint32_t newPaRAMFieldVal)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set a particular PaRAM set field of the specified PaRAM set.  <a href="#ga6b57b385ba8fca2757da48f714550f99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga58d0eb4347d9aad2035d60054e70a6bb">EDMA3_DRV_getPaRAMField</a> (EDMA3_DRV_Handle hEdma, uint32_t lCh, <a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#ga3e31ba1b02dcbace3044c11c83ef5466">EDMA3_DRV_PaRAMField</a> paRAMField, uint32_t *currPaRAMFieldVal)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a particular PaRAM set field of the specified PaRAM set.  <a href="#ga58d0eb4347d9aad2035d60054e70a6bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga6a6c40cddb7bb7bc74635e104757e225">EDMA3_DRV_setEvtQPriority</a> (EDMA3_DRV_Handle hEdma, const <a class="el" href="struct_e_d_m_a3___d_r_v___evt_que_priority.html">EDMA3_DRV_EvtQuePriority</a> *evtQPriObj)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets EDMA TC priority.  <a href="#ga6a6c40cddb7bb7bc74635e104757e225"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga858eae593371bd2e8e88ea31ca89dee2">EDMA3_DRV_mapChToEvtQ</a> (EDMA3_DRV_Handle hEdma, uint32_t channelId, EDMA3_RM_EventQueue eventQ)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Associate Channel to Event Queue.  <a href="#ga858eae593371bd2e8e88ea31ca89dee2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga113009d6273cb3079376c41780bea56f">EDMA3_DRV_getMapChToEvtQ</a> (EDMA3_DRV_Handle hEdma, uint32_t channelId, uint32_t *mappedEvtQ)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the Event Queue mapped to the specified DMA/QDMA channel.  <a href="#ga113009d6273cb3079376c41780bea56f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga4e63b90bcd4fdc809fa28f73eac708b0">EDMA3_DRV_setCCRegister</a> (EDMA3_DRV_Handle hEdma, uint32_t regOffset, uint32_t newRegValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Set the Channel Controller (CC) Register value.  <a href="#ga4e63b90bcd4fdc809fa28f73eac708b0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#gae76237491d2e0fb58094b8a22b551943">EDMA3_DRV_getCCRegister</a> (EDMA3_DRV_Handle hEdma, uint32_t regOffset, uint32_t *regValue)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the Channel Controller (CC) Register value.  <a href="#gae76237491d2e0fb58094b8a22b551943"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#gacbb02cd93e37f680e9ce6c4a710c6769">EDMA3_DRV_waitAndClearTcc</a> (EDMA3_DRV_Handle hEdma, uint32_t tccNo)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for a transfer completion interrupt to occur and clear it.  <a href="#gacbb02cd93e37f680e9ce6c4a710c6769"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#gae954e4efc65de14d1f863b83b6bf85a9">EDMA3_DRV_checkAndClearTcc</a> (EDMA3_DRV_Handle hEdma, uint32_t tccNo, uint16_t *tccStatus)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the status of a previously initiated transfer.  <a href="#gae954e4efc65de14d1f863b83b6bf85a9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga8f3c8ae97270c310f740d5eb95ae014a">EDMA3_DRV_getPaRAMPhyAddr</a> (EDMA3_DRV_Handle hEdma, uint32_t lCh, uint32_t *paramPhyAddr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the PaRAM Set Physical Address associated with a logical channel.  <a href="#ga8f3c8ae97270c310f740d5eb95ae014a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga379162d6a5076160d4ed2e01ca8dcac6">EDMA3_DRV_Ioctl</a> (EDMA3_DRV_Handle hEdma, <a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#ga8577940463f7ca5a8977b2fb65fae19a">EDMA3_DRV_IoctlCmd</a> cmd, void *cmdArg, void *param)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">EDMA3 Driver IOCTL.  <a href="#ga379162d6a5076160d4ed2e01ca8dcac6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Handle&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga5b2b47b7f30d5232fae53bbf5e38ad17">EDMA3_DRV_getInstHandle</a> (uint32_t phyCtrllerInstId, EDMA3_RM_RegionId regionId, EDMA3_DRV_Result *errorCode)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the previously opened EDMA3 Driver Instance handle.  <a href="#ga5b2b47b7f30d5232fae53bbf5e38ad17"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga88d42967b207c6cf6f15862e1c7d562c">EDMA3_DRV_registerTccCb</a> (EDMA3_DRV_Handle hEdma, const uint32_t channelId, EDMA3_RM_TccCallback tccCb, void *cbData)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Registers a transfer completion handler for a specific DMA/QDMA channel.  <a href="#ga88d42967b207c6cf6f15862e1c7d562c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga472684db77a1980ea38a2eb9acaea649">EDMA3_DRV_unregisterTccCb</a> (EDMA3_DRV_Handle hEdma, const uint32_t channelId)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Un-register the previously registered callback function against a DMA/QDMA channel.  <a href="#ga472684db77a1980ea38a2eb9acaea649"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#gaad724400dcbc9418ab1122a0c047efd2">EDMA3_DRV_setTcErrorInt</a> (uint32_t phyCtrllerInstId, uint32_t tcId, <a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#ga2b3b55b1d7c987a7873d8b0b085173b2">EDMA3_DRV_Tc_Err</a> tcErr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Enable/disable specific EDMA3 Transfer Controller Interrupts.  <a href="#gaad724400dcbc9418ab1122a0c047efd2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga0241fe8f5788e4b4b217d650a383cf39">EDMA3_DRV_getChannelStatus</a> (EDMA3_DRV_Handle hEdma, uint32_t lCh, uint32_t *lchStatus)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the current status of the DMA/QDMA channel.  <a href="#ga0241fe8f5788e4b4b217d650a383cf39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#gaeff038764ab896e127e803557d543f7f">EDMA3_DRV_mapTccLinkCh</a> (EDMA3_DRV_Handle hEdma, uint32_t linkCh, uint32_t tcc)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Associates a link channel and a TCC.  <a href="#gaeff038764ab896e127e803557d543f7f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">EDMA3_DRV_Result&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga1ff9d2ede0fb29c7194f15ba58ad8e0f">EDMA3_DRV_initXbarEventMap</a> (EDMA3_DRV_Handle hEdma, const <a class="el" href="struct_e_d_m_a3___d_r_v___gbl_xbar_to_chan_config_params.html">EDMA3_DRV_GblXbarToChanConfigParams</a> *edmaGblXbarConfig, <a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#gaba09a1e3f0dbc70cff309a0030776168">EDMA3_DRV_mapXbarEvtToChan</a> mapXbarEvtFunc, <a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga44bf9e6ccf89645f0fcd1c345d8b5fde">EDMA3_DRV_xbarConfigScr</a> configXbarScr)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the cross bar mapped event to channel function.  <a href="#ga1ff9d2ede0fb29c7194f15ba58ad8e0f"></a><br/></td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gaba09a1e3f0dbc70cff309a0030776168"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_mapXbarEvtToChan" ref="gaba09a1e3f0dbc70cff309a0030776168" args=")(uint32_t eventNum, uint32_t *chanNum, const EDMA3_DRV_GblXbarToChanConfigParams *edmaGblXbarConfig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef EDMA3_DRV_Result(* <a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#gaba09a1e3f0dbc70cff309a0030776168">EDMA3_DRV_mapXbarEvtToChan</a>)(uint32_t eventNum, uint32_t *chanNum, const <a class="el" href="struct_e_d_m_a3___d_r_v___gbl_xbar_to_chan_config_params.html">EDMA3_DRV_GblXbarToChanConfigParams</a> *edmaGblXbarConfig)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Associates cross bar mapped event to channel. </p>
<p>This function have to be defined in the configuration file. This function will be called only if the channel requested for is beyond the maximum number of channels. This function should read from the global cross bar mapped configuration data structure and return the mapped channel number to this event.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eventNum</em>&nbsp;</td><td>[IN] Event number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chanNum</em>&nbsp;</td><td>[IN/OUT]Return the channel number to which the request event is mapped to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>edmaGblXbarConfig</em>&nbsp;</td><td>[IN] This is the configuration data structure for mapping the events to the channel</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for unique event values. It is non-re-entrant for same event values. </dd></dl>

</div>
</div>
<a class="anchor" id="ga44bf9e6ccf89645f0fcd1c345d8b5fde"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_xbarConfigScr" ref="ga44bf9e6ccf89645f0fcd1c345d8b5fde" args=")(uint32_t eventNum, uint32_t chanNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef EDMA3_DRV_Result(* <a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga44bf9e6ccf89645f0fcd1c345d8b5fde">EDMA3_DRV_xbarConfigScr</a>)(uint32_t eventNum, uint32_t chanNum)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Writes to the cross bar mapped event to channel to system configuration register. </p>
<p>This function have to be defined in the configuration file. This function will be called only if the event number requested for is beyond the maximum number of channels and if any channel is allocated to this event. This function should read the cross bar mapped event number and write the allocated channel number in Control Config Event Mux registers.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>eventNum</em>&nbsp;</td><td>[IN] Event number </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chanNum</em>&nbsp;</td><td>[IN/OUT]Return the channel number to which the request event is mapped to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for unique event values. It is non-re-entrant for same event values. </dd></dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga5d0ac2830ede7245fc7a7b02666c4651"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_linkChannel" ref="ga5d0ac2830ede7245fc7a7b02666c4651" args="(EDMA3_DRV_Handle hEdma, uint32_t lCh1, uint32_t lCh2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_linkChannel </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lCh1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lCh2</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Link two logical channels. </p>
<p>This API is used to link two previously allocated logical (DMA/QDMA/Link) channels.</p>
<p>It sets the Link field of the PaRAM set associated with first logical channel (lCh1) to point it to the PaRAM set associated with second logical channel (lCh2).</p>
<p>It also sets the TCC field of PaRAM set of second logical channel to the same as that of the first logical channel, only if the TCC field doesnot contain a valid TCC code. In case the second logical channel has its own TCC, the TCC field remains unchanged.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lCh1</em>&nbsp;</td><td>[IN] Logical Channel to which particular channel will be linked. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lCh2</em>&nbsp;</td><td>[IN] Logical Channel which needs to be linked to the first channel. After the transfer based on the PaRAM set of lCh1 is over, the PaRAM set of lCh2 will be copied to the PaRAM set of lCh1 and transfer will resume. For DMA channels, another sync event is required to initiate the transfer on the Link channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for unique lCh1 &amp; lCh2 values. It is non-re-entrant for same lCh1 &amp; lCh2 values. </dd></dl>

</div>
</div>
<a class="anchor" id="gab385b2ade87dab8377a3116d5957b4b3"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_unlinkChannel" ref="gab385b2ade87dab8377a3116d5957b4b3" args="(EDMA3_DRV_Handle hEdma, uint32_t lCh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_unlinkChannel </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lCh</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unlink the channel from the earlier linked logical channel. </p>
<p>This function breaks the link between the specified channel and the earlier linked logical channel by clearing the Link Address field.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lCh</em>&nbsp;</td><td>[IN] Channel for which linking has to be removed</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for unique lCh values. It is non- re-entrant for same lCh value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga523dba0bb68b6a6762ee72d92bd4a003"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_chainChannel" ref="ga523dba0bb68b6a6762ee72d92bd4a003" args="(EDMA3_DRV_Handle hEdma, uint32_t lCh1, uint32_t lCh2, const EDMA3_DRV_ChainOptions *chainOptions)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_chainChannel </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lCh1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lCh2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_e_d_m_a3___d_r_v___chain_options.html">EDMA3_DRV_ChainOptions</a> *&nbsp;</td>
          <td class="paramname"> <em>chainOptions</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Chain the two specified channels. </p>
<p>This API is used to chain a DMA channel to a previously allocated DMA/QDMA channel.</p>
<p>Chaining is different from Linking. The EDMA3 link feature reloads the current channel parameter set with the linked parameter set. The EDMA3 chaining feature does not modify or update any channel parameter set; it provides a synchronization event (or trigger) to the chained DMA channel, as soon as the transfer (final or intermediate) completes on the main DMA/QDMA channel.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lCh1</em>&nbsp;</td><td>[IN] DMA/QDMA channel to which a particular DMA channel will be chained. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lCh2</em>&nbsp;</td><td>[IN] DMA channel which needs to be chained to the first DMA/QDMA channel. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>chainOptions</em>&nbsp;</td><td>[IN] Options such as intermediate interrupts are required or not, intermediate/final chaining is enabled or not etc.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for unique lCh1 &amp; lCh2 values. It is non-re-entrant for same lCh1 &amp; lCh2 values. </dd></dl>

</div>
</div>
<a class="anchor" id="gaea1980b0debbfca7099beddc82613f30"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_unchainChannel" ref="gaea1980b0debbfca7099beddc82613f30" args="(EDMA3_DRV_Handle hEdma, uint32_t lCh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_unchainChannel </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lCh</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unchain the two channels. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lCh</em>&nbsp;</td><td>[IN] Channel whose chaining with the other channel has to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for unique lCh values. It is non- re-entrant for same lCh value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga216c695659e783937361893e2954be67"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_setQdmaTrigWord" ref="ga216c695659e783937361893e2954be67" args="(EDMA3_DRV_Handle hEdma, uint32_t lCh, EDMA3_RM_QdmaTrigWord trigWord)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_setQdmaTrigWord </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EDMA3_RM_QdmaTrigWord&nbsp;</td>
          <td class="paramname"> <em>trigWord</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assign a Trigger Word to the specified QDMA channel. </p>
<p>This API sets the Trigger word for the specific QDMA channel in the QCHMAP Register. Default QDMA trigger word is CCNT.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Instance object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lCh</em>&nbsp;</td><td>[IN] QDMA Channel which needs to be assigned the Trigger Word </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>trigWord</em>&nbsp;</td><td>[IN] The Trigger Word for the QDMA channel. Trigger Word is the word in the PaRAM Register Set which, when written to by CPU, will start the QDMA transfer automatically.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for unique lCh values. It is non- re-entrant for same lCh value. </dd></dl>

</div>
</div>
<a class="anchor" id="gae701899e3ecaffde66019991cc075e06"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_setPaRAM" ref="gae701899e3ecaffde66019991cc075e06" args="(EDMA3_DRV_Handle hEdma, uint32_t lCh, const EDMA3_DRV_PaRAMRegs *newPaRAM)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_setPaRAM </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_e_d_m_a3___d_r_v___pa_r_a_m_regs.html">EDMA3_DRV_PaRAMRegs</a> *&nbsp;</td>
          <td class="paramname"> <em>newPaRAM</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy the user specified PaRAM Set onto the PaRAM Set associated with the logical channel (DMA/QDMA/Link). </p>
<p>This API takes a PaRAM Set as input and copies it onto the actual PaRAM Set associated with the logical channel. OPT field of the PaRAM Set is written first and the CCNT field is written last.</p>
<p>Caution: It should be used carefully when programming the QDMA channels whose trigger words are not CCNT field.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Instance object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lCh</em>&nbsp;</td><td>[IN] Logical Channel for which new PaRAM set is specified </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newPaRAM</em>&nbsp;</td><td>[IN] Parameter RAM set to be copied onto existing PaRAM</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for unique lCh values. It is non- re-entrant for same lCh value. </dd></dl>

</div>
</div>
<a class="anchor" id="gab7a95585219b3140771a6c7e07dea1ee"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_getPaRAM" ref="gab7a95585219b3140771a6c7e07dea1ee" args="(EDMA3_DRV_Handle hEdma, uint32_t lCh, EDMA3_DRV_PaRAMRegs *currPaRAM)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_getPaRAM </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_e_d_m_a3___d_r_v___pa_r_a_m_regs.html">EDMA3_DRV_PaRAMRegs</a> *&nbsp;</td>
          <td class="paramname"> <em>currPaRAM</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Retrieve existing PaRAM set associated with specified logical channel (DMA/QDMA/Link). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Instance object </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lCh</em>&nbsp;</td><td>[IN] Logical Channel whose PaRAM set is requested </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>currPaRAM</em>&nbsp;</td><td>[IN/OUT] User gets the existing PaRAM here</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga801246bc529343f0324d125c65537fe8"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_setPaRAMEntry" ref="ga801246bc529343f0324d125c65537fe8" args="(EDMA3_DRV_Handle hEdma, uint32_t lCh, EDMA3_DRV_PaRAMEntry paRAMEntry, uint32_t newPaRAMEntryVal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_setPaRAMEntry </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#ga82b01ec2292a13ad48a5bfcc724dfac6">EDMA3_DRV_PaRAMEntry</a>&nbsp;</td>
          <td class="paramname"> <em>paRAMEntry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>newPaRAMEntryVal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a particular PaRAM set entry of the specified PaRAM set. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lCh</em>&nbsp;</td><td>[IN] Logical Channel bound to the Parameter RAM set whose specified field needs to be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paRAMEntry</em>&nbsp;</td><td>[IN] Specify the PaRAM set entry which needs to be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newPaRAMEntryVal</em>&nbsp;</td><td>[IN] The new field setting</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This API should be used while setting the PaRAM set entry for QDMA channels. If EDMA3_DRV_setPaRAMField () used, it will trigger the QDMA channel before complete PaRAM set entry is written. For DMA channels, no such constraint is there.</dd></dl>
<p>This function is re-entrant for unique lCh values. It is non- re-entrant for same lCh value. </p>

</div>
</div>
<a class="anchor" id="gad131a9d84d316d8c2c73c37ad8f6b520"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_getPaRAMEntry" ref="gad131a9d84d316d8c2c73c37ad8f6b520" args="(EDMA3_DRV_Handle hEdma, uint32_t lCh, EDMA3_DRV_PaRAMEntry paRAMEntry, uint32_t *paRAMEntryVal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_getPaRAMEntry </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#ga82b01ec2292a13ad48a5bfcc724dfac6">EDMA3_DRV_PaRAMEntry</a>&nbsp;</td>
          <td class="paramname"> <em>paRAMEntry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>paRAMEntryVal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a particular PaRAM set entry of the specified PaRAM set. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lCh</em>&nbsp;</td><td>[IN] Logical Channel bound to the Parameter RAM set whose specified field value is needed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paRAMEntry</em>&nbsp;</td><td>[IN] Specify the PaRAM set entry which needs to be obtained </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paRAMEntryVal</em>&nbsp;</td><td>[IN/OUT] The value of the field is returned here</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6b57b385ba8fca2757da48f714550f99"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_setPaRAMField" ref="ga6b57b385ba8fca2757da48f714550f99" args="(EDMA3_DRV_Handle hEdma, uint32_t lCh, EDMA3_DRV_PaRAMField paRAMField, uint32_t newPaRAMFieldVal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_setPaRAMField </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#ga3e31ba1b02dcbace3044c11c83ef5466">EDMA3_DRV_PaRAMField</a>&nbsp;</td>
          <td class="paramname"> <em>paRAMField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>newPaRAMFieldVal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set a particular PaRAM set field of the specified PaRAM set. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lCh</em>&nbsp;</td><td>[IN] Logical Channel bound to the PaRAM set whose specified field needs to be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paRAMField</em>&nbsp;</td><td>[IN] Specify the PaRAM set field which needs to be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newPaRAMFieldVal</em>&nbsp;</td><td>[IN] The new field setting</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This API CANNOT be used while setting the PaRAM set field for QDMA channels. It can trigger the QDMA channel before complete PaRAM set ENTRY (4-bytes field) is written (for eg, as soon one sets the ACNT field for QDMA channel, transfer is started, before one modifies the BCNT field). For DMA channels, no such constraint is there.</dd></dl>
<p>This function is re-entrant for unique lCh values. It is non- re-entrant for same lCh value. </p>

</div>
</div>
<a class="anchor" id="ga58d0eb4347d9aad2035d60054e70a6bb"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_getPaRAMField" ref="ga58d0eb4347d9aad2035d60054e70a6bb" args="(EDMA3_DRV_Handle hEdma, uint32_t lCh, EDMA3_DRV_PaRAMField paRAMField, uint32_t *currPaRAMFieldVal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_getPaRAMField </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#ga3e31ba1b02dcbace3044c11c83ef5466">EDMA3_DRV_PaRAMField</a>&nbsp;</td>
          <td class="paramname"> <em>paRAMField</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>currPaRAMFieldVal</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a particular PaRAM set field of the specified PaRAM set. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lCh</em>&nbsp;</td><td>[IN] Logical Channel bound to the PaRAM set whose specified field value is needed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paRAMField</em>&nbsp;</td><td>[IN] Specify the PaRAM set field which needs to be obtained </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>currPaRAMFieldVal</em>&nbsp;</td><td>[IN/OUT] The value of the field is returned here</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6a6c40cddb7bb7bc74635e104757e225"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_setEvtQPriority" ref="ga6a6c40cddb7bb7bc74635e104757e225" args="(EDMA3_DRV_Handle hEdma, const EDMA3_DRV_EvtQuePriority *evtQPriObj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_setEvtQPriority </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_e_d_m_a3___d_r_v___evt_que_priority.html">EDMA3_DRV_EvtQuePriority</a> *&nbsp;</td>
          <td class="paramname"> <em>evtQPriObj</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets EDMA TC priority. </p>
<p>User can program the priority of the Event Queues at a system-wide level. This means that the user can set the priority of an IO initiated by either of the TCs (Transfer Ctrllers) relative to IO initiated by the other bus masters on the device (ARM, DSP, USB, etc)</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>evtQPriObj</em>&nbsp;</td><td>[IN] Priority of the Event Queues</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function disables the global interrupts while modifying the global CC Registers, to make it re-entrant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga858eae593371bd2e8e88ea31ca89dee2"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_mapChToEvtQ" ref="ga858eae593371bd2e8e88ea31ca89dee2" args="(EDMA3_DRV_Handle hEdma, uint32_t channelId, EDMA3_RM_EventQueue eventQ)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_mapChToEvtQ </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>channelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EDMA3_RM_EventQueue&nbsp;</td>
          <td class="paramname"> <em>eventQ</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Associate Channel to Event Queue. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channelId</em>&nbsp;</td><td>[IN] Logical Channel to which the Event Queue is to be mapped </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>eventQ</em>&nbsp;</td><td>[IN] The Event Queue which is to be mapped to the DMA channel</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>There should not be any data transfer going on while setting the mapping. Results could be unpredictable.</dd></dl>
<p>This function disables the global interrupts while modifying the global CC Registers, to make it re-entrant. </p>

</div>
</div>
<a class="anchor" id="ga113009d6273cb3079376c41780bea56f"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_getMapChToEvtQ" ref="ga113009d6273cb3079376c41780bea56f" args="(EDMA3_DRV_Handle hEdma, uint32_t channelId, uint32_t *mappedEvtQ)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_getMapChToEvtQ </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>channelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>mappedEvtQ</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the Event Queue mapped to the specified DMA/QDMA channel. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channelId</em>&nbsp;</td><td>[IN] Logical Channel whose associated Event Queue is needed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mappedEvtQ</em>&nbsp;</td><td>[IN/OUT] The Event Queue which is mapped to the DMA/QDMA channel</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4e63b90bcd4fdc809fa28f73eac708b0"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_setCCRegister" ref="ga4e63b90bcd4fdc809fa28f73eac708b0" args="(EDMA3_DRV_Handle hEdma, uint32_t regOffset, uint32_t newRegValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_setCCRegister </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>regOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>newRegValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Set the Channel Controller (CC) Register value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>regOffset</em>&nbsp;</td><td>[IN] CC Register offset whose value needs to be set </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>newRegValue</em>&nbsp;</td><td>[IN] New CC Register Value</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is non re-entrant for users using the same EDMA handle i.e. working on the same shadow region. Before modifying a register, it tries to acquire a semaphore (Driver instance specific), to protect simultaneous modification of the same register by two different users. After the successful change, it releases the semaphore. For users working on different shadow regions, thus different EDMA handles, this function is re-entrant. </dd></dl>

</div>
</div>
<a class="anchor" id="gae76237491d2e0fb58094b8a22b551943"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_getCCRegister" ref="gae76237491d2e0fb58094b8a22b551943" args="(EDMA3_DRV_Handle hEdma, uint32_t regOffset, uint32_t *regValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_getCCRegister </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>regOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>regValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the Channel Controller (CC) Register value. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>regOffset</em>&nbsp;</td><td>[IN] CC Register offset whose value is needed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>regValue</em>&nbsp;</td><td>[IN/OUT] CC Register Value</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant. </dd></dl>

</div>
</div>
<a class="anchor" id="gacbb02cd93e37f680e9ce6c4a710c6769"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_waitAndClearTcc" ref="gacbb02cd93e37f680e9ce6c4a710c6769" args="(EDMA3_DRV_Handle hEdma, uint32_t tccNo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_waitAndClearTcc </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>tccNo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Wait for a transfer completion interrupt to occur and clear it. </p>
<p>This is a blocking function that returns when the IPR/IPRH bit corresponding to the tccNo specified, is SET. It clears the corresponding bit while returning also.</p>
<p>This function waits for the specific bit indefinitely in a tight loop, with out any delay in between. USE IT CAUTIOUSLY.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tccNo</em>&nbsp;</td><td>[IN] TCC, specific to which the function waits on a IPR/IPRH bit.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for different tccNo. </dd></dl>

</div>
</div>
<a class="anchor" id="gae954e4efc65de14d1f863b83b6bf85a9"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_checkAndClearTcc" ref="gae954e4efc65de14d1f863b83b6bf85a9" args="(EDMA3_DRV_Handle hEdma, uint32_t tccNo, uint16_t *tccStatus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_checkAndClearTcc </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>tccNo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&nbsp;</td>
          <td class="paramname"> <em>tccStatus</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the status of a previously initiated transfer. </p>
<p>This is a non-blocking function that returns the status of a previously initiated transfer, based on the IPR/IPRH bit. This bit corresponds to the tccNo specified by the user. It clears the corresponding bit, if SET, while returning also.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tccNo</em>&nbsp;</td><td>[IN] TCC, specific to which the function checks the status of the IPR/IPRH bit. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tccStatus</em>&nbsp;</td><td>[IN/OUT] Status of the transfer is returned here. Returns "TRUE" if the transfer has completed (IPR/IPRH bit SET), "FALSE" if the transfer has not completed successfully (IPR/IPRH bit NOT SET).</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for different tccNo. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8f3c8ae97270c310f740d5eb95ae014a"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_getPaRAMPhyAddr" ref="ga8f3c8ae97270c310f740d5eb95ae014a" args="(EDMA3_DRV_Handle hEdma, uint32_t lCh, uint32_t *paramPhyAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_getPaRAMPhyAddr </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>paramPhyAddr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the PaRAM Set Physical Address associated with a logical channel. </p>
<p>This function returns the PaRAM Set Phy Address (unsigned 32 bits). The returned address could be used by the advanced users to program the PaRAM Set directly without using any APIs.</p>
<p>Least significant 16 bits of this address could be used to program the LINK field in the PaRAM Set. Users which program the LINK field directly SHOULD use this API to get the associated PaRAM Set address with the LINK channel.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lCh</em>&nbsp;</td><td>[IN] Logical Channel for which the PaRAM set physical address is required </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>paramPhyAddr</em>&nbsp;</td><td>[IN/OUT] PaRAM Set physical address is returned here.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant. </dd></dl>

</div>
</div>
<a class="anchor" id="ga379162d6a5076160d4ed2e01ca8dcac6"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_Ioctl" ref="ga379162d6a5076160d4ed2e01ca8dcac6" args="(EDMA3_DRV_Handle hEdma, EDMA3_DRV_IoctlCmd cmd, void *cmdArg, void *param)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_Ioctl </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#ga8577940463f7ca5a8977b2fb65fae19a">EDMA3_DRV_IoctlCmd</a>&nbsp;</td>
          <td class="paramname"> <em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cmdArg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>param</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>EDMA3 Driver IOCTL. </p>
<p>This function provides IOCTL functionality for EDMA3 Driver.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmd</em>&nbsp;</td><td>[IN] IOCTL command to be performed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cmdArg</em>&nbsp;</td><td>[IN/OUT] IOCTL command argument (if any) </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>param</em>&nbsp;</td><td>[IN/OUT] Device/Cmd specific argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>For 'EDMA3_DRV_IOCTL_GET_PARAM_CLEAR_OPTION', this function is re-entrant. For 'EDMA3_DRV_IOCTL_SET_PARAM_CLEAR_OPTION', this function is re-entrant for different EDMA3 Driver Instances (handles). </dd></dl>

</div>
</div>
<a class="anchor" id="ga5b2b47b7f30d5232fae53bbf5e38ad17"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_getInstHandle" ref="ga5b2b47b7f30d5232fae53bbf5e38ad17" args="(uint32_t phyCtrllerInstId, EDMA3_RM_RegionId regionId, EDMA3_DRV_Result *errorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Handle EDMA3_DRV_getInstHandle </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>phyCtrllerInstId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EDMA3_RM_RegionId&nbsp;</td>
          <td class="paramname"> <em>regionId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EDMA3_DRV_Result *&nbsp;</td>
          <td class="paramname"> <em>errorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Return the previously opened EDMA3 Driver Instance handle. </p>
<p>This API is used to return the previously opened EDMA3 Driver's Instance Handle (region specific), which could be used to call other EDMA3 Driver APIs. Since EDMA3 Driver does not allow multiple instances, for a single shadow region, this API is provided. This API is meant for users who DO NOT want to / could not open a new Driver Instance and hence re-use the existing Driver Instance to allocate EDMA3 resources and use various other EDMA3 Driver APIs.</p>
<p>In case the Driver Instance is not yet opened, NULL is returned as the function return value whereas EDMA3_DRV_E_INST_NOT_OPENED is returned in the errorCode.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>phyCtrllerInstId</em>&nbsp;</td><td>[IN] EDMA3 Controller Instance Id (Hardware instance id, starting from 0). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>regionId</em>&nbsp;</td><td>[IN] Shadow Region id for which the previously opened driver's instance handle is required. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>errorCode</em>&nbsp;</td><td>[OUT] Error code while returning Driver Instance Handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_Handle : If successful, this API will return the driver's instance handle.</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>1) This API returns the previously opened EDMA3 Driver's Instance handle. The instance, if exists, could have been opened by some other user (most probably) or may be by the same user calling this API. If it was opened by some other user, then that user can very well close this instance anytime, without even knowing that the same instance handle is being used by other users as well. In that case, the handle becomes INVALID and user has to open a valid driver instance for his/her use.</dd></dl>
<p>2) This function is re-entrant. </p>

</div>
</div>
<a class="anchor" id="ga88d42967b207c6cf6f15862e1c7d562c"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_registerTccCb" ref="ga88d42967b207c6cf6f15862e1c7d562c" args="(EDMA3_DRV_Handle hEdma, const uint32_t channelId, EDMA3_RM_TccCallback tccCb, void *cbData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_registerTccCb </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&nbsp;</td>
          <td class="paramname"> <em>channelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EDMA3_RM_TccCallback&nbsp;</td>
          <td class="paramname"> <em>tccCb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cbData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Registers a transfer completion handler for a specific DMA/QDMA channel. </p>
<p>This function registers a non-NULL callback function for a specific DMA or QDMA channel and enables the completion interrupt for the TCC associated with the underlying channel in the IER/IERH register. It also sets the DRAE/DRAEH register for the TCC associated with the specified DMA/QDMA channel. If user enables the transfer completion interrupts (intermediate or final) in the OPT field of the associated PaRAM Set, the registered callback function will be called by the EDMA3 Resource Manager.</p>
<p>If a call-back function is already registered for the channel, the API fails with the error code EDMA3_RM_E_CALLBACK_ALREADY_REGISTERED.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channelId</em>&nbsp;</td><td>[IN] DMA/QDMA channel for which the callback function needs to be registered. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tccCb</em>&nbsp;</td><td>[IN] The callback function to be registered. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cbData</em>&nbsp;</td><td>[IN] Callback data to be passed while calling the callback function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for unique channelId values. It is non- re-entrant for same channelId value. </dd></dl>

</div>
</div>
<a class="anchor" id="ga472684db77a1980ea38a2eb9acaea649"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_unregisterTccCb" ref="ga472684db77a1980ea38a2eb9acaea649" args="(EDMA3_DRV_Handle hEdma, const uint32_t channelId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_unregisterTccCb </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&nbsp;</td>
          <td class="paramname"> <em>channelId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Un-register the previously registered callback function against a DMA/QDMA channel. </p>
<p>This function un-registers the previously registered callback function for the DMA/QDMA channel by removing any stored callback function. Moreover, it clears the: Interrupt Enable Register (IER/IERH) by writing to the IECR/IECRH register, for the TCC associated with that particular channel, DRA/DRAEH register for the TCC associated with the specified DMA/QDMA channel</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>channelId</em>&nbsp;</td><td>[IN] DMA/QDMA channel for which the callback function needs to be un-registered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for unique channelId. It is non-re-entrant for same channelId. </dd></dl>

</div>
</div>
<a class="anchor" id="gaad724400dcbc9418ab1122a0c047efd2"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_setTcErrorInt" ref="gaad724400dcbc9418ab1122a0c047efd2" args="(uint32_t phyCtrllerInstId, uint32_t tcId, EDMA3_DRV_Tc_Err tcErr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_setTcErrorInt </td>
          <td>(</td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>phyCtrllerInstId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>tcId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___s_y_m_b_o_l___e_n_u_m.html#ga2b3b55b1d7c987a7873d8b0b085173b2">EDMA3_DRV_Tc_Err</a>&nbsp;</td>
          <td class="paramname"> <em>tcErr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Enable/disable specific EDMA3 Transfer Controller Interrupts. </p>
<p>This function allows one to enable/disable specific EDMA3 Transfer Controller Interrupts. Since these interrupts don't get enabled by default, this API can be used to achieve the same.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>phyCtrllerInstId</em>&nbsp;</td><td>[IN] EDMA3 Controller Instance Id (Hardware instance id, starting from 0). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tcId</em>&nbsp;</td><td>[IN] Transfer Controller Id. It starts from 0 for each EDMA3 hardware and can go upto (TCs available on EDMA3 Hardware - 1). </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tcErr</em>&nbsp;</td><td>[IN] TC Error Interrupts which need to be enabled/disabled.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for unique combination of EDMA3 hw and TC. It is non-re-entrant for same combination. </dd></dl>

</div>
</div>
<a class="anchor" id="ga0241fe8f5788e4b4b217d650a383cf39"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_getChannelStatus" ref="ga0241fe8f5788e4b4b217d650a383cf39" args="(EDMA3_DRV_Handle hEdma, uint32_t lCh, uint32_t *lchStatus)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_getChannelStatus </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>lCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>lchStatus</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get the current status of the DMA/QDMA channel. </p>
<p>This function returns the current status of the specific DMA/QDMA channel. For a DMA channel, it checks whether an event is pending in ER, transfer completion interrupt is pending in IPR and event miss error interrupt is pending in EMR or not. For a QDMA channel, it checks whether a transfer completion interrupt is pending in IPR and event miss error interrupt is pending in QEMR or not.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lCh</em>&nbsp;</td><td>[IN] DMA/QDMA channel for which the current status is required. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>lchStatus</em>&nbsp;</td><td>[IN/OUT]Status of the channel. Defines mentioned above are used (and may be combined) to return the actual status.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant. </dd></dl>

</div>
</div>
<a class="anchor" id="gaeff038764ab896e127e803557d543f7f"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_mapTccLinkCh" ref="gaeff038764ab896e127e803557d543f7f" args="(EDMA3_DRV_Handle hEdma, uint32_t linkCh, uint32_t tcc)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_mapTccLinkCh </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>linkCh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>tcc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Associates a link channel and a TCC. </p>
<p>This API is used to map a TCC to a LINK channel. It should be used with LINK channels ONLY else it will fail. It will copy the TCC code in the OPT field of the param set associated with the link channel.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>linkCh</em>&nbsp;</td><td>[IN] Link Channel to which a particular TCC needs to be mapped. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tcc</em>&nbsp;</td><td>[IN] TCC which needs to be mapped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function is re-entrant for unique linkCh values. It is non-re-entrant for same linkCh values. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1ff9d2ede0fb29c7194f15ba58ad8e0f"></a><!-- doxytag: member="edma3_drv.h::EDMA3_DRV_initXbarEventMap" ref="ga1ff9d2ede0fb29c7194f15ba58ad8e0f" args="(EDMA3_DRV_Handle hEdma, const EDMA3_DRV_GblXbarToChanConfigParams *edmaGblXbarConfig, EDMA3_DRV_mapXbarEvtToChan mapXbarEvtFunc, EDMA3_DRV_xbarConfigScr configXbarScr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">EDMA3_DRV_Result EDMA3_DRV_initXbarEventMap </td>
          <td>(</td>
          <td class="paramtype">EDMA3_DRV_Handle&nbsp;</td>
          <td class="paramname"> <em>hEdma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_e_d_m_a3___d_r_v___gbl_xbar_to_chan_config_params.html">EDMA3_DRV_GblXbarToChanConfigParams</a> *&nbsp;</td>
          <td class="paramname"> <em>edmaGblXbarConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#gaba09a1e3f0dbc70cff309a0030776168">EDMA3_DRV_mapXbarEvtToChan</a>&nbsp;</td>
          <td class="paramname"> <em>mapXbarEvtFunc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group___e_d_m_a3___l_l_d___d_r_v___f_u_n_c_t_i_o_n___a_d_v_a_n_c_e_d.html#ga44bf9e6ccf89645f0fcd1c345d8b5fde">EDMA3_DRV_xbarConfigScr</a>&nbsp;</td>
          <td class="paramname"> <em>configXbarScr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize the cross bar mapped event to channel function. </p>
<p>This API provides interface to associate the cross bar mapped event to edma channel in the driver. This function will called by the application during initilization. User could pass the application specific configuration structure during init-time. In case user doesn't provide it, this information could be taken from the SoC specific configuration file edma3_&lt;SOC_NAME&gt;_cfg.c, in case it is available. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>hEdma</em>&nbsp;</td><td>[IN] Handle to the EDMA Driver Instance. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>edmaGblXbarConfig</em>&nbsp;</td><td>[IN] This is the configuration data structure for mapping the events to the channel </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>mapXbarEvtFunc</em>&nbsp;</td><td>[IN] This is the user defined function for mapping the cross bar event to channel.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>EDMA3_DRV_SOK or EDMA3_DRV Error Code</dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>This function disables the global interrupts (by calling API edma3OsProtectEntry with protection level EDMA3_OS_PROTECT_INTERRUPT) while modifying the global data structures, to make it re-entrant. </dd></dl>

</div>
</div>
</div>
<hr size="1"/><address style="text-align: right;"><small>Generated on Mon Feb 14 18:34:01 2011 for EDMA3 Driver by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.1 </small></address>
</body>
</html>
