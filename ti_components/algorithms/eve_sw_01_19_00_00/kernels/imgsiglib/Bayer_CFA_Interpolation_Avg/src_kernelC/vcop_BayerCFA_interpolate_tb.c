/*
*
* Copyright (c) 2009-2017 Texas Instruments Incorporated
*
* All rights reserved not granted herein.
*
* Limited License.
*
* Texas Instruments Incorporated grants a world-wide, royalty-free, non-exclusive
* license under copyrights and patents it now or hereafter owns or controls to make,
* have made, use, import, offer to sell and sell ("Utilize") this software subject to the
* terms herein.  With respect to the foregoing patent license, such license is granted
* solely to the extent that any such patent is necessary to Utilize the software alone.
* The patent license shall not apply to any combinations which include this software,
* other than combinations with devices manufactured by or for TI ("TI Devices").
* No hardware patent is licensed hereunder.
*
* Redistributions must preserve existing copyright notices and reproduce this license
* (including the above copyright notice and the disclaimer and (if applicable) source
* code license limitations below) in the documentation and/or other materials provided
* with the distribution
*
* Redistribution and use in binary form, without modification, are permitted provided
* that the following conditions are met:
*
* *       No reverse engineering, decompilation, or disassembly of this software is
* permitted with respect to any software provided in binary form.
*
* *       any redistribution and use are licensed by TI for use only with TI Devices.
*
* *       Nothing shall obligate TI to provide you with source code for the software
* licensed and provided to you in object code.
*
* If software source code is provided to you, modification and redistribution of the
* source code are permitted provided that the following conditions are met:
*
* *       any redistribution and use of the source code, including any resulting derivative
* works, are licensed by TI for use only with TI Devices.
*
* *       any redistribution and use of any object code compiled from the source code
* and any resulting derivative works, are licensed by TI for use only with TI Devices.
*
* Neither the name of Texas Instruments Incorporated nor the names of its suppliers
*
* may be used to endorse or promote products derived from this software without
* specific prior written permission.
*
* DISCLAIMER.
*
* THIS SOFTWARE IS PROVIDED BY TI AND TI'S LICENSORS "AS IS" AND ANY EXPRESS
* OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
* IN NO EVENT SHALL TI AND TI'S LICENSORS BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
* BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
* DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
* OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
* OF THE POSSIBILITY OF SUCH DAMAGE.
*
*/



/*-----------------------------------------------------------------*/
/* NAME : vcop_BayerCFA_interpolate                                */
/*                                                                 */
/*                                                                 */
/* DESCRIPTION:                                                    */
/* The "vcop_BayerCFA_interpolate" code accepts 8 or 16-bit data   */
/* in the form of 8 or 16-bit Bayer Pattern, and writes out        */
/* the result as separate R, G and B planes. The output is         */
/* interpolated data to match the input width and height.          */
/* Interpolation is carried out by averaging the left and right    */
/* pixels, or the top and bottom pixels as the case may be.        */
/* In some cases, all four of the top-bottom-left-right pixels are */
/* used to compute the center pixel value.                         */
/*                                                                 */
/* The Bayer pattern is as follows:                                */
/* -------------------------------                                 */
/* B G B G B G B G                                                 */
/* G R G R G R G R                                                 */
/* B G B G B G B G                                                 */
/* G R G R G R G R                                                 */
/* B G B G B G B G                                                 */
/* G R G R G R G R                                                 */
/*                                                                 */
/* After demosiacing or deinterleaving step we get:                */
/* ------------------------------------------------                */
/* B  bx B  bx B  bx  B                                            */
/* by bz by bz by bz  by                                           */
/* B  bx B  bx B  bx  B                                            */
/* by bz by bz by bz  by                                           */
/*                                                                 */
/* rz ry rz ry rz  ry ry                                           */
/* rx R  rx R  rx  R  R                                            */
/* rz ry rz ry rz  ry ry                                           */
/* rx R  rx R  rx  R  R                                            */
/*                                                                 */
/* gy G gy  G  gy G  gy                                            */
/* G  gx G  gx G  gx  G                                            */
/* gy G gy  G  gy G  gy                                            */
/* G  gx G  gx G  gx  G                                            */
/*                                                                 */
/* At this stage, bx, by, bz, rx, ry, rz, gx, gy are zeros.        */
/*                                                                 */
/* After interpolating we get:                                     */
/* ---------------------------                                     */
/* Where bx = (Bleft + Bright)/2                                   */
/* Where by = (Btop  + Bbottom)/2                                  */
/* Where bz = (Bleft + Bright + Btop + Bbottom)/4                  */
/*                                                                 */
/* Where rx = (Rleft + Rright)/2                                   */
/* Where ry = (Rtop  + Rbottom)/2                                  */
/* Where rz = (Rleft + Rright + Rtop + Rbottom)/4                  */
/*                                                                 */
/* Where gx = (Gleft + Gright)/2                                   */
/* Where gy = (Gtop  + Gbottom)/2                                  */
/*                                                                 */
/* API:                                                            */
/*                                                                 */
/* void vcop_BayerCFA_Interpolate_char                             */
/* (                                                               */
/*     __vptr_uint8   CFA_char,                                    */
/*     unsigned int   blk_w,                                       */
/*     unsigned int   blk_h,                                       */
/*     __vptr_uint8   R_char,                                      */
/*     __vptr_uint8   G_char,                                      */
/*     __vptr_uint8   B_char                                       */
/* );                                                              */
/*                                                                 */
/*                                                                 */
/* void vcop__BayerCFA_Interpolate_short                           */
/* (                                                               */
/*     __vptr_uint16  CFA_short,                                   */
/*     unsigned int   blk_w,                                       */
/*     unsigned int   blk_h,                                       */
/*     __vptr_uint16  R_short,                                     */
/*     __vptr_uint16  G_short,                                     */
/*     __vptr_uint16  B_short                                      */
/* );                                                              */
/*                                                                 */
/*                                                                 */
/*=================================================================*/


#include <stdio.h>
#include <vcop.h>

#include "test_profile.h"

typedef unsigned short Uint16;
typedef unsigned char  Uint8;

#define IN_W         32
#define IN_H         32

// IMPORTANT!! BLK_W should be a multiple of 16
#define BLK_W        16
#define BLK_H        10

#define  N0           (IN_W * IN_H)
#define  Nout         (BLK_W * BLK_H)

#pragma DATA_SECTION (CFA_char, "Adata");
unsigned char CFA_char[N0] =
{

    0x40, 0x30, 0x42, 0x32, 0x45, 0x34, 0x44, 0x33, 0x42, 0x30, 0x42, 0x32, 0x46, 0x31, 0x42, 0x32,
    0x40, 0x30, 0x42, 0x32, 0x45, 0x34, 0x44, 0x33, 0x42, 0x30, 0x42, 0x32, 0x46, 0x31, 0x42, 0x32,
    0x35, 0x20, 0x32, 0x22, 0x36, 0x26, 0x32, 0x25, 0x37, 0x21, 0x32, 0x22, 0x35, 0x21, 0x32, 0x22,
    0x35, 0x20, 0x32, 0x22, 0x36, 0x26, 0x32, 0x25, 0x37, 0x21, 0x32, 0x22, 0x35, 0x21, 0x32, 0x22,
    0x40, 0x30, 0x42, 0x32, 0x45, 0x34, 0x44, 0x33, 0x42, 0x30, 0x42, 0x32, 0x46, 0x31, 0x42, 0x32,
    0x40, 0x30, 0x42, 0x32, 0x45, 0x34, 0x44, 0x33, 0x42, 0x30, 0x42, 0x32, 0x46, 0x31, 0x42, 0x32,
    0x35, 0x20, 0x32, 0x22, 0x36, 0x26, 0x32, 0x25, 0x37, 0x21, 0x32, 0x22, 0x35, 0x21, 0x32, 0x22,
    0x35, 0x20, 0x32, 0x22, 0x36, 0x26, 0x32, 0x25, 0x37, 0x21, 0x32, 0x22, 0x35, 0x21, 0x32, 0x22,
    0x40, 0x30, 0x42, 0x32, 0x45, 0x34, 0x44, 0x33, 0x42, 0x30, 0x42, 0x32, 0x46, 0x31, 0x42, 0x32,
    0x40, 0x30, 0x42, 0x32, 0x45, 0x34, 0x44, 0x33, 0x42, 0x30, 0x42, 0x32, 0x46, 0x31, 0x42, 0x32,
    0x35, 0x20, 0x32, 0x22, 0x36, 0x26, 0x32, 0x25, 0x37, 0x21, 0x32, 0x22, 0x35, 0x21, 0x32, 0x22,
    0x35, 0x20, 0x32, 0x22, 0x36, 0x26, 0x32, 0x25, 0x37, 0x21, 0x32, 0x22, 0x35, 0x21, 0x32, 0x22,
    0x40, 0x30, 0x42, 0x32, 0x45, 0x34, 0x44, 0x33, 0x42, 0x30, 0x42, 0x32, 0x46, 0x31, 0x42, 0x32,
    0x40, 0x30, 0x42, 0x32, 0x45, 0x34, 0x44, 0x33, 0x42, 0x30, 0x42, 0x32, 0x46, 0x31, 0x42, 0x32,
    0x35, 0x20, 0x32, 0x22, 0x36, 0x26, 0x32, 0x25, 0x37, 0x21, 0x32, 0x22, 0x35, 0x21, 0x32, 0x22,
    0x35, 0x20, 0x32, 0x22, 0x36, 0x26, 0x32, 0x25, 0x37, 0x21, 0x32, 0x22, 0x35, 0x21, 0x32, 0x22,
    0x40, 0x30, 0x42, 0x32, 0x45, 0x34, 0x44, 0x33, 0x42, 0x30, 0x42, 0x32, 0x46, 0x31, 0x42, 0x32,
    0x40, 0x30, 0x42, 0x32, 0x45, 0x34, 0x44, 0x33, 0x42, 0x30, 0x42, 0x32, 0x46, 0x31, 0x42, 0x32,
    0x35, 0x20, 0x32, 0x22, 0x36, 0x26, 0x32, 0x25, 0x37, 0x21, 0x32, 0x22, 0x35, 0x21, 0x32, 0x22,
    0x35, 0x20, 0x32, 0x22, 0x36, 0x26, 0x32, 0x25, 0x37, 0x21, 0x32, 0x22, 0x35, 0x21, 0x32, 0x22,

};

#pragma DATA_SECTION (CFA_short, "Adata");
unsigned short CFA_short[N0] =
{
    0x140, 0x230, 0x142, 0x232, 0x145, 0x234, 0x144, 0x233, 0x142, 0x230, 0x142, 0x232, 0x146, 0x231, 0x142, 0x232,
    0x140, 0x230, 0x142, 0x232, 0x145, 0x234, 0x144, 0x233, 0x142, 0x230, 0x142, 0x232, 0x146, 0x231, 0x142, 0x232,
    0x235, 0x320, 0x232, 0x322, 0x236, 0x326, 0x232, 0x325, 0x237, 0x321, 0x232, 0x322, 0x235, 0x321, 0x232, 0x322,
    0x235, 0x320, 0x232, 0x322, 0x236, 0x326, 0x232, 0x325, 0x237, 0x321, 0x232, 0x322, 0x235, 0x321, 0x232, 0x322,
    0x140, 0x230, 0x142, 0x232, 0x145, 0x234, 0x144, 0x233, 0x142, 0x230, 0x142, 0x232, 0x146, 0x231, 0x142, 0x232,
    0x140, 0x230, 0x142, 0x232, 0x145, 0x234, 0x144, 0x233, 0x142, 0x230, 0x142, 0x232, 0x146, 0x231, 0x142, 0x232,
    0x235, 0x320, 0x232, 0x322, 0x236, 0x326, 0x232, 0x325, 0x237, 0x321, 0x232, 0x322, 0x235, 0x321, 0x232, 0x322,
    0x235, 0x320, 0x232, 0x322, 0x236, 0x326, 0x232, 0x325, 0x237, 0x321, 0x232, 0x322, 0x235, 0x321, 0x232, 0x322,

    0x140, 0x230, 0x142, 0x232, 0x145, 0x234, 0x144, 0x233, 0x142, 0x230, 0x142, 0x232, 0x146, 0x231, 0x142, 0x232,
    0x140, 0x230, 0x142, 0x232, 0x145, 0x234, 0x144, 0x233, 0x142, 0x230, 0x142, 0x232, 0x146, 0x231, 0x142, 0x232,
    0x235, 0x320, 0x232, 0x322, 0x236, 0x326, 0x232, 0x325, 0x237, 0x321, 0x232, 0x322, 0x235, 0x321, 0x232, 0x322,
    0x235, 0x320, 0x232, 0x322, 0x236, 0x326, 0x232, 0x325, 0x237, 0x321, 0x232, 0x322, 0x235, 0x321, 0x232, 0x322,
    0x140, 0x230, 0x142, 0x232, 0x145, 0x234, 0x144, 0x233, 0x142, 0x230, 0x142, 0x232, 0x146, 0x231, 0x142, 0x232,
    0x140, 0x230, 0x142, 0x232, 0x145, 0x234, 0x144, 0x233, 0x142, 0x230, 0x142, 0x232, 0x146, 0x231, 0x142, 0x232,
    0x235, 0x320, 0x232, 0x322, 0x236, 0x326, 0x232, 0x325, 0x237, 0x321, 0x232, 0x322, 0x235, 0x321, 0x232, 0x322,
    0x235, 0x320, 0x232, 0x322, 0x236, 0x326, 0x232, 0x325, 0x237, 0x321, 0x232, 0x322, 0x235, 0x321, 0x232, 0x322,

    0x140, 0x230, 0x142, 0x232, 0x145, 0x234, 0x144, 0x233, 0x142, 0x230, 0x142, 0x232, 0x146, 0x231, 0x142, 0x232,
    0x140, 0x230, 0x142, 0x232, 0x145, 0x234, 0x144, 0x233, 0x142, 0x230, 0x142, 0x232, 0x146, 0x231, 0x142, 0x232,
    0x235, 0x320, 0x232, 0x322, 0x236, 0x326, 0x232, 0x325, 0x237, 0x321, 0x232, 0x322, 0x235, 0x321, 0x232, 0x322,
    0x235, 0x320, 0x232, 0x322, 0x236, 0x326, 0x232, 0x325, 0x237, 0x321, 0x232, 0x322, 0x235, 0x321, 0x232, 0x322,
    0x140, 0x230, 0x142, 0x232, 0x145, 0x234, 0x144, 0x233, 0x142, 0x230, 0x142, 0x232, 0x146, 0x231, 0x142, 0x232,
    0x140, 0x230, 0x142, 0x232, 0x145, 0x234, 0x144, 0x233, 0x142, 0x230, 0x142, 0x232, 0x146, 0x231, 0x142, 0x232,
    0x235, 0x320, 0x232, 0x322, 0x236, 0x326, 0x232, 0x325, 0x237, 0x321, 0x232, 0x322, 0x235, 0x321, 0x232, 0x322,
    0x235, 0x320, 0x232, 0x322, 0x236, 0x326, 0x232, 0x325, 0x237, 0x321, 0x232, 0x322, 0x235, 0x321, 0x232, 0x322,


};

#pragma DATA_SECTION (R1, "Cdata");
unsigned char R1[Nout] = {0};

#pragma DATA_SECTION (G1, "Cdata");
#pragma DATA_ALIGN(G1, 32);
unsigned char G1[Nout] = {0};

#pragma DATA_SECTION (B1, "Cdata");
#pragma DATA_ALIGN(B1, 32);
unsigned char B1[Nout] = {0};

#pragma DATA_SECTION (ER1, "EOutdata");
unsigned char ER1[Nout] =
{
    // R - DATA
    0x20, 0x21, 0x22, 0x24, 0x26, 0x25, 0x25, 0x23, 0x21, 0x21, 0x22, 0x21, 0x21, 0x21, 0x22, 0x11,
    0x20, 0x21, 0x22, 0x24, 0x26, 0x25, 0x25, 0x23, 0x21, 0x21, 0x22, 0x21, 0x21, 0x21, 0x22, 0x11,
    0x20, 0x21, 0x22, 0x24, 0x26, 0x25, 0x25, 0x23, 0x21, 0x21, 0x22, 0x21, 0x21, 0x21, 0x22, 0x11,
    0x20, 0x21, 0x22, 0x24, 0x26, 0x25, 0x25, 0x23, 0x21, 0x21, 0x22, 0x21, 0x21, 0x21, 0x22, 0x11,
    0x20, 0x21, 0x22, 0x24, 0x26, 0x25, 0x25, 0x23, 0x21, 0x21, 0x22, 0x21, 0x21, 0x21, 0x22, 0x11,
    0x20, 0x21, 0x22, 0x24, 0x26, 0x25, 0x25, 0x23, 0x21, 0x21, 0x22, 0x21, 0x21, 0x21, 0x22, 0x11,
    0x20, 0x21, 0x22, 0x24, 0x26, 0x25, 0x25, 0x23, 0x21, 0x21, 0x22, 0x21, 0x21, 0x21, 0x22, 0x11,
    0x20, 0x21, 0x22, 0x24, 0x26, 0x25, 0x25, 0x23, 0x21, 0x21, 0x22, 0x21, 0x21, 0x21, 0x22, 0x11,
};

#pragma DATA_SECTION (EG1, "EOutdata");
unsigned char EG1[Nout] =
{
    // G - DATA
    0x30, 0x31, 0x32, 0x33, 0x34, 0x33, 0x33, 0x31, 0x30, 0x31, 0x32, 0x31, 0x31, 0x31, 0x32, 0x33,
    0x35, 0x33, 0x32, 0x34, 0x36, 0x34, 0x32, 0x34, 0x37, 0x34, 0x32, 0x33, 0x35, 0x33, 0x32, 0x31,
    0x30, 0x31, 0x32, 0x33, 0x34, 0x33, 0x33, 0x31, 0x30, 0x31, 0x32, 0x31, 0x31, 0x31, 0x32, 0x33,
    0x35, 0x33, 0x32, 0x34, 0x36, 0x34, 0x32, 0x34, 0x37, 0x34, 0x32, 0x33, 0x35, 0x33, 0x32, 0x31,
    0x30, 0x31, 0x32, 0x33, 0x34, 0x33, 0x33, 0x31, 0x30, 0x31, 0x32, 0x31, 0x31, 0x31, 0x32, 0x33,
    0x35, 0x33, 0x32, 0x34, 0x36, 0x34, 0x32, 0x34, 0x37, 0x34, 0x32, 0x33, 0x35, 0x33, 0x32, 0x31,
    0x30, 0x31, 0x32, 0x33, 0x34, 0x33, 0x33, 0x31, 0x30, 0x31, 0x32, 0x31, 0x31, 0x31, 0x32, 0x33,
    0x35, 0x33, 0x32, 0x34, 0x36, 0x34, 0x32, 0x34, 0x37, 0x34, 0x32, 0x33, 0x35, 0x33, 0x32, 0x31,
};

#pragma DATA_SECTION (EB1, "EOutdata");
unsigned char EB1[Nout] =
{
    
    // B - DATA
    0x40, 0x41, 0x42, 0x43, 0x45, 0x44, 0x44, 0x43, 0x42, 0x42, 0x42, 0x44, 0x46, 0x44, 0x42, 0x21,
    0x40, 0x41, 0x42, 0x43, 0x45, 0x44, 0x44, 0x43, 0x42, 0x42, 0x42, 0x44, 0x46, 0x44, 0x42, 0x21,
    0x40, 0x41, 0x42, 0x43, 0x45, 0x44, 0x44, 0x43, 0x42, 0x42, 0x42, 0x44, 0x46, 0x44, 0x42, 0x21,
    0x40, 0x41, 0x42, 0x43, 0x45, 0x44, 0x44, 0x43, 0x42, 0x42, 0x42, 0x44, 0x46, 0x44, 0x42, 0x21,
    0x40, 0x41, 0x42, 0x43, 0x45, 0x44, 0x44, 0x43, 0x42, 0x42, 0x42, 0x44, 0x46, 0x44, 0x42, 0x21,
    0x40, 0x41, 0x42, 0x43, 0x45, 0x44, 0x44, 0x43, 0x42, 0x42, 0x42, 0x44, 0x46, 0x44, 0x42, 0x21,
    0x40, 0x41, 0x42, 0x43, 0x45, 0x44, 0x44, 0x43, 0x42, 0x42, 0x42, 0x44, 0x46, 0x44, 0x42, 0x21,
    0x40, 0x41, 0x42, 0x43, 0x45, 0x44, 0x44, 0x43, 0x42, 0x42, 0x42, 0x44, 0x46, 0x44, 0x42, 0x21,
};

#pragma DATA_SECTION (R2, "Cdata");
unsigned short R2[Nout] = {0};

#pragma DATA_SECTION (G2, "Cdata");
unsigned short G2[Nout] = {0};

#pragma DATA_SECTION (B2, "Cdata");
unsigned short B2[Nout] = {0};

#pragma DATA_SECTION (ER2, "EOutdata");
unsigned short ER2[Nout] =
{

    // R - DATA
    0x320, 0x321, 0x322, 0x324, 0x326, 0x325, 0x325, 0x323, 0x321, 0x321, 0x322, 0x321, 0x321, 0x321, 0x322, 0x191,
    0x320, 0x321, 0x322, 0x324, 0x326, 0x325, 0x325, 0x323, 0x321, 0x321, 0x322, 0x321, 0x321, 0x321, 0x322, 0x191,
    0x320, 0x321, 0x322, 0x324, 0x326, 0x325, 0x325, 0x323, 0x321, 0x321, 0x322, 0x321, 0x321, 0x321, 0x322, 0x191,
    0x320, 0x321, 0x322, 0x324, 0x326, 0x325, 0x325, 0x323, 0x321, 0x321, 0x322, 0x321, 0x321, 0x321, 0x322, 0x191,
    0x320, 0x321, 0x322, 0x324, 0x326, 0x325, 0x325, 0x323, 0x321, 0x321, 0x322, 0x321, 0x321, 0x321, 0x322, 0x191,
    0x320, 0x321, 0x322, 0x324, 0x326, 0x325, 0x325, 0x323, 0x321, 0x321, 0x322, 0x321, 0x321, 0x321, 0x322, 0x191,
    0x320, 0x321, 0x322, 0x324, 0x326, 0x325, 0x325, 0x323, 0x321, 0x321, 0x322, 0x321, 0x321, 0x321, 0x322, 0x191,
    0x320, 0x321, 0x322, 0x324, 0x326, 0x325, 0x325, 0x323, 0x321, 0x321, 0x322, 0x321, 0x321, 0x321, 0x322, 0x191,
};

#pragma DATA_SECTION (EG2, "EOutdata");
unsigned short EG2[Nout] =
{
    // G - DATA
    0x230, 0x231, 0x232, 0x233, 0x234, 0x233, 0x233, 0x231, 0x230, 0x231, 0x232, 0x231, 0x231, 0x231, 0x232, 0x233,
    0x235, 0x233, 0x232, 0x234, 0x236, 0x234, 0x232, 0x234, 0x237, 0x234, 0x232, 0x233, 0x235, 0x233, 0x232, 0x231,
    0x230, 0x231, 0x232, 0x233, 0x234, 0x233, 0x233, 0x231, 0x230, 0x231, 0x232, 0x231, 0x231, 0x231, 0x232, 0x233,
    0x235, 0x233, 0x232, 0x234, 0x236, 0x234, 0x232, 0x234, 0x237, 0x234, 0x232, 0x233, 0x235, 0x233, 0x232, 0x231,
    0x230, 0x231, 0x232, 0x233, 0x234, 0x233, 0x233, 0x231, 0x230, 0x231, 0x232, 0x231, 0x231, 0x231, 0x232, 0x233,
    0x235, 0x233, 0x232, 0x234, 0x236, 0x234, 0x232, 0x234, 0x237, 0x234, 0x232, 0x233, 0x235, 0x233, 0x232, 0x231,
    0x230, 0x231, 0x232, 0x233, 0x234, 0x233, 0x233, 0x231, 0x230, 0x231, 0x232, 0x231, 0x231, 0x231, 0x232, 0x233,
    0x235, 0x233, 0x232, 0x234, 0x236, 0x234, 0x232, 0x234, 0x237, 0x234, 0x232, 0x233, 0x235, 0x233, 0x232, 0x231,
};

#pragma DATA_SECTION (EB2, "EOutdata");
unsigned short EB2[Nout] =
{
    // B - DATA
    0x140, 0x141, 0x142, 0x143, 0x145, 0x144, 0x144, 0x143, 0x142, 0x142, 0x142, 0x144, 0x146, 0x144, 0x142, 0xa1,
    0x140, 0x141, 0x142, 0x143, 0x145, 0x144, 0x144, 0x143, 0x142, 0x142, 0x142, 0x144, 0x146, 0x144, 0x142, 0xa1,
    0x140, 0x141, 0x142, 0x143, 0x145, 0x144, 0x144, 0x143, 0x142, 0x142, 0x142, 0x144, 0x146, 0x144, 0x142, 0xa1,
    0x140, 0x141, 0x142, 0x143, 0x145, 0x144, 0x144, 0x143, 0x142, 0x142, 0x142, 0x144, 0x146, 0x144, 0x142, 0xa1,
    0x140, 0x141, 0x142, 0x143, 0x145, 0x144, 0x144, 0x143, 0x142, 0x142, 0x142, 0x144, 0x146, 0x144, 0x142, 0xa1,
    0x140, 0x141, 0x142, 0x143, 0x145, 0x144, 0x144, 0x143, 0x142, 0x142, 0x142, 0x144, 0x146, 0x144, 0x142, 0xa1,
    0x140, 0x141, 0x142, 0x143, 0x145, 0x144, 0x144, 0x143, 0x142, 0x142, 0x142, 0x144, 0x146, 0x144, 0x142, 0xa1,
    0x140, 0x141, 0x142, 0x143, 0x145, 0x144, 0x144, 0x143, 0x142, 0x142, 0x142, 0x144, 0x146, 0x144, 0x142, 0xa1,
};

#if VCOP_HOST_EMULATION
  #include "vcop_BayerCFA_interpolate_kernel.k"           // kernel source
#else
  #include "../inc/vcop_BayerCFA_interpolate_kernel.h"    // translated kernel
#endif

void print_output();
int  verify_output();

int main()
{
    int ok = 0;

#ifdef REPORT
FILE* fpReport = fopen("../../../report.csv","a+");
#ifdef SCTM
unsigned int sctm_t1, sctm_t2, exec_diff;
unsigned int overflow;
EVE_SCTM_Enable(CTM);
EVE_SCTM_CounterConfig(CTM, SCTM_Counter_0, VCOP_BUSY, SCTM_DURATION);
EVE_SCTM_CounterTimerEnable(CTM, SCTM_Counter_0);
#endif
#endif

#ifdef REPORT
#ifdef SCTM
sctm_t1 = EVE_SCTM_CounterRead (CTM, SCTM_Counter_0);
#endif
#endif    	
    vcop_BayerCFA_interpolate_char
    (
        &CFA_char[0],
        IN_W,
        BLK_W,
        BLK_H,
        R1,
        G1,
        B1
   );

    vcop_BayerCFA_interpolate_short
    (
        &CFA_short[0],
        IN_W,
        BLK_W,
        BLK_H,
        R2,
        G2,
        B2
    );

#ifdef REPORT	
#ifdef SCTM
sctm_t2 = EVE_SCTM_CounterRead (CTM, SCTM_Counter_0);
		overflow= EVE_SCTM_OverflowCheck(CTM,SCTM_Counter_0);
		assert(overflow!=1);

exec_diff = sctm_t2 - sctm_t1;		
EVE_SCTM_CounterTimerDisable(CTM, SCTM_Counter_0);
#endif			
#endif
#ifdef REPORT
fprintf(fpReport,"vcop_BayerCFA_interpolate,");
fprintf(fpReport,"%d,",IN_W);
fprintf(fpReport,"%d,",IN_H);
fprintf(fpReport,"%d,",BLK_W);
fprintf(fpReport,"%d,",BLK_H);
fprintf(fpReport,"1,");
#endif	   	
	
#ifdef CONSOLE
   print_output();
#endif   
   ok = verify_output();

#ifdef CONSOLE   
   if (ok )   printf("\n\nBayer Color Filter Array interpolation, 8 and 16-bit to R, G and B planes -- Kernel-C code: PASS\n\n\n"); 
   else printf("\n\nFAIL\n\n");
#endif   
#ifdef REPORT   
if(ok){
fprintf(fpReport,"PASS,");
}
else{
fprintf(fpReport,"FAIL,");
}
#ifdef SCTM
fprintf(fpReport,"%d\n",exec_diff);
#endif
if(fpReport){
fclose(fpReport);
}
#endif

return 0;
}

void print_output()
{
   int i, j;

   printf("\n\n INPUT - DATA  \n");
   for (i = 0; i < BLK_H; ++i)
   {
       for ( j = 0; j < BLK_W; j++)
       {
           printf("0x%2.2x, ", CFA_char[(i * IN_W) + j]); 
           
       }
       printf("\n");
   }
 
   printf("\n\n R - DATA  \n");
   for (i = 0; i < BLK_H - 2; i++)
   {
       for ( j = 0; j < BLK_W; j++)
       {
           printf("0x%2.2x, ", R1[(i * BLK_W) + j]); 
           
       }
       printf("\n");
   }
 
   printf("\n\n G - DATA  \n");
   for (i = 0; i < BLK_H - 2; i++)
   {
       for ( j = 0; j < BLK_W; j++)
       {
           printf("0x%2.2x, ", G1[(i * BLK_W) + j]); 
           
       }
       printf("\n");
   }

   printf("\n\n B - DATA  \n");
   for (i = 0; i < BLK_H - 2; i++)
   {
       for ( j = 0; j < BLK_W; j++)
       {
           printf("0x%2.2x, ", B1[(i * BLK_W) + j]); 
           
       }
       printf("\n");
   }

   printf("\n\n R - DATA  \n");
   for (i = 0; i < BLK_H - 2; ++i)
   {
       for ( j = 0; j < BLK_W; j++)
       {
           printf("0x%2.2x, ", R2[(i * BLK_W) + j]); 
           
       }
       printf("\n");
   }
 
   printf("\n\n G - DATA  \n");
   for (i = 0; i < BLK_H - 2; ++i)
   {
       for ( j = 0; j < BLK_W; j++)
       {
           printf("0x%2.2x, ", G2[(i * BLK_W) + j]); 
           
       }
       printf("\n");
   }

   printf("\n\n B - DATA  \n");
   for (i = 0; i < BLK_H - 2; ++i)
   {
       for ( j = 0; j < BLK_W; j++)
       {
           printf("0x%2.2x, ", B2[(i * BLK_W) + j]); 
           
       }
       printf("\n");
   }

}

int verify_output()
{
   int i, j;
   int ok = 1;

   for (i = 0; i < BLK_H - 2; ++i)
   {
       for ( j = 0; j < BLK_W; j++)
       {
           if (R1[(i * BLK_W) + j] != ER1[(i * BLK_W) + j])
               ok = 0;
       }
   }


   for (i = 0; i < BLK_H - 2; ++i)
   {
       for ( j = 0; j < BLK_W; j++)
       {
           if (G1[(i * BLK_W) + j] != EG1[(i * BLK_W) + j])
               ok = 0;
       }
   }


   for (i = 0; i < BLK_H - 2; ++i)
   {
       for ( j = 0; j < BLK_W; j++)
       {
           if (B1[(i * BLK_W) + j] != EB1[(i * BLK_W) + j])
               ok = 0;
       }
   }

   for (i = 0; i < BLK_H - 2; ++i)
   {
       for ( j = 0; j < BLK_W; j++)
       {
           if (R2[(i * BLK_W) + j] != ER2[(i * BLK_W) + j])
               ok = 0;
       }
   }


   for (i = 0; i < BLK_H - 2; ++i)
   {
       for ( j = 0; j < BLK_W; j++)
       {
           if (G2[(i * BLK_W) + j] != EG2[(i * BLK_W) + j])
               ok = 0;
       }
   }


   for (i = 0; i < BLK_H - 2; ++i)
   {
       for ( j = 0; j < BLK_W; j++)
       {
           if (B2[(i * BLK_W) + j] != EB2[(i * BLK_W) + j])
               ok = 0;
       }
   }

  return (ok);

}

/*=================================================================*/
/* End of file: vcop_BayerCFA_interpolate.c                        */
/*-----------------------------------------------------------------*/
/* Texas Instruments Incorporated 2009-2012.                       */
/*-----------------------------------------------------------------*/
