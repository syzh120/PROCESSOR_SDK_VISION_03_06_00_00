<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>VLIB: VLIB_harrisScore_7x7_S32</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>VLIB_harrisScore_7x7_S32</h1><hr><a name="_details"></a><h2>Detailed Description</h2>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l_i_b__harris_score__7x7___s32.html#gac61b25c52fc8071d12997433ffba51a">VLIB_harrisScore_7x7_S32</a> (const int16_t gradX[restrict], const int16_t gradY[restrict], int32_t width, int32_t height, int32_t outm[restrict], uint16_t k, uint8_t buffer[])</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gac61b25c52fc8071d12997433ffba51a"></a><!-- doxytag: member="c66/VLIB_harrisScore_7x7_S32.h::VLIB_harrisScore_7x7_S32" ref="gac61b25c52fc8071d12997433ffba51a" args="(const int16_t gradX[restrict], const int16_t gradY[restrict], int32_t width, int32_t height, int32_t outm[restrict], uint16_t k, uint8_t buffer[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t VLIB_harrisScore_7x7_S32           </td>
          <td>(</td>
          <td class="paramtype">const int16_t&nbsp;</td>
          <td class="paramname"> <em>gradX</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t&nbsp;</td>
          <td class="paramname"> <em>gradY</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>outm</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>buffer</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Description</b></dt><dd>This function computes the Harris corner score for each pixel in a luma image. As input, the function takes the horizontal and vertical gradients of the image. This gives flexibility to the user in selecting the scale for gradient computations.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>gradX[]</em>&nbsp;</td><td>Horizontal gradient of the input luma image (SQ15.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>gradY[]</em>&nbsp;</td><td>Vertical gradient of the input luma image (SQ15.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>width</em>&nbsp;</td><td>Image width (SQ31.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>height</em>&nbsp;</td><td>Image height (SQ31.0) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>outm[]</em>&nbsp;</td><td>Harris (cornerness) score (exp=5 man=27) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>k</em>&nbsp;</td><td>Sensitivity parameter (UQ1.15) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buffer[]</em>&nbsp;</td><td>Scratch buffer (UQ8.0)</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Method</b></dt><dd>For each pixel, the following equations together compute the 2x2 gradient covariance matrix M, where the summations are over 7x7 pixel neighborhoods: <div class="fragment"><pre class="fragment">

    M(1,1) = sum(gradX)^2
    M(1,2) = M(2,1) = sum(gradX x gradY)
    M(2,2) = sum(gradY)^2
    </pre></div> The cornerness score is defined as in the following equation, where k is a tunable sensitivity parameter, typically around 0.04. The underlying score computation generates a signed 47 bit result, which is internally computed using signed 64-bit data types (int64_t). <div class="fragment"><pre class="fragment">
    Score (signed 47-bit)   = det(M) - k * trace(M)^2
</pre></div> To save memory storing this data, the algorithm compresses this output to 16 bits using an approximation of the binary log. Order relationships between different score values is maintained in this format, up to the quantization limits. Such a format is superior compared to simple rounding in therms of quantization errors as the below format preserves maximum number of bits from the original score. The exact format of Harris score stored in outm[] is as follows: <div class="fragment"><pre class="fragment">

    Exponent = 6bit, Mantissa = 26 bit (eg. EEEE EEMM MMMM MMMM MMMM MMMM MMMM MMMMb)
                                            where E: Exponent bits, M: Mantissa bits
    </pre></div> The exponent corresponds to the location of the leading non-redundant sign-bit in the score (where the lsb is location = 1, and msb is location = 64). The mantissa contains the relevant bits (26 bits) starting from the leading non-redundant sign bit. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The exponent is 0 if the absolute value of the score is less than 2^26. If the absolute value of the score is greater than 2^26, (lmb - 26) is stored in the exponent for positive scores, and -(lmb - 26) is stored in the exponent for negative scores. For example, a signed score of 571717286 (= 0010 0010 0001 0011 1011 0110 1010 0110b) will be encoded as = (30-26)*2^26 + (571717286)&gt;&gt;(30-26)=304167786.</dd></dl>
<dl class="user" compact><dt><b>Assumptions</b></dt><dd><ul>
<li>Garbage may be written in the output margins, which are 3 pixels wide on each side. If the input gradient also has a margin of 1 pixel, then there is an overall output margin of 4 pixels.</li><li>This method uses a scratch buffer which must be at least 96 * <code>width</code> bytes.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Benchmarks:</b></dt><dd>See VLIB_Test_Report.html for cycle and memory information. </dd></dl>

</div>
</div><p>
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
