<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>VLIB: VLIB_binarySkeleton</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>VLIB_binarySkeleton</h1><hr><a name="_details"></a><h2>Detailed Description</h2>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l_i_b__binary_skeleton.html#g99d76dcbcd615f74b902c724bf247eea">VLIB_hitmiss_bin</a> (const uint32_t in_data[restrict], uint32_t out_data[restrict], const uint8_t mask[restrict], const uint8_t mask_d[restrict], int32_t cols, int32_t pitch)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l_i_b__binary_skeleton.html#g35a51781a7f40ef91cf47a97c88b1065">VLIB_binarySkeleton</a> (const uint32_t in_data[restrict], uint32_t out_data[restrict], uint32_t scratch[restrict], uint8_t mask[][VLIB_BINSKEL_MASK_SZ], uint8_t mask_d[][VLIB_BINSKEL_MASK_SZ], uint16_t width, uint16_t height, uint8_t num_st, uint8_t *iters)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g99d76dcbcd615f74b902c724bf247eea"></a><!-- doxytag: member="c66/VLIB_binarySkeleton.h::VLIB_hitmiss_bin" ref="g99d76dcbcd615f74b902c724bf247eea" args="(const uint32_t in_data[restrict], uint32_t out_data[restrict], const uint8_t mask[restrict], const uint8_t mask_d[restrict], int32_t cols, int32_t pitch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VLIB_hitmiss_bin           </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&nbsp;</td>
          <td class="paramname"> <em>in_data</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>out_data</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>mask</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>mask_d</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>pitch</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Description:</b></dt><dd>This function computes Hit-Miss operation using a single programmable 3x3 mask (<code>mask</code>[]) and its respective "don't care" mask (<code>mask_d</code>[]).</dd></dl>
In Hit-Miss, a single 3x3 mask is represented by 1's (foreground), 0's (background), and X's (don't cares). This API uses two parameters to specify this information: <code>mask</code>[] and <code>mask_d</code>[]. The 1's and 0's locations in the mask are specified using the <code>mask</code>[] parameter, and the X's (don't care) locations are specified by using 1 values in the <code>mask_d</code>[] paramter, as shown below. <div class="fragment"><pre class="fragment">
    Example:
           1 0 1             1 0 1              0 0 0
     For:  X 1 X  :  mask =  0 1 0    mask_d =  1 0 1
           X 0 X             0 0 0              1 0 1
   </pre></div><p>
In the above example, output pixel is 1 if: the input pixel (center pixel) is 1, it has a one valued northwest and northeast neighbors, and it has a zero valued north and south neighbors. Other neighbors are not considered (don't cares).<p>
This function may be called by multiple times on the same image using different structuring elements, such is the case in the <a class="el" href="group___v_l_i_b__binary_skeleton.html">VLIB_binarySkeleton</a> function.<p>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>in_data[]</em>&nbsp;</td><td>Input image pointer (32-bit packed binary) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>out_data[]</em>&nbsp;</td><td>Output image pointer (32-bit packed binary) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mask[]</em>&nbsp;</td><td>Pointer to a 3x3 structural element mask (UQ8.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mask_d[]</em>&nbsp;</td><td>Pointer to a 3x3 "don't care" mask (UQ8.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>cols</em>&nbsp;</td><td>Number of pixels to process (SQ31.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pitch</em>&nbsp;</td><td>Pitch of the input image (in terms of number of bits) (SQ31.0)</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Assumptions:</b></dt><dd><ul>
<li>The <code>in_data</code> and <code>out_data</code> buffers are assumed to be 4 byte aligned and not aliased.</li><li>The input <code>pitch</code> must be multiples of 32.</li><li>The input <code>cols:</code> <ul>
<li>must be &gt;= 128, and</li><li>must be multiples of 64, and</li><li>should have a maximum value equal to the pitch * (height - 2), where height is the height of the in_data buffer. <code>cols</code> is equivalent to the number of output pixels (bits) that are written to starting from the out_data pointer.</li></ul>
</li><li>The bit-packed input and output are ordered the same way as pixels in the image. This is different from the IMGLIB requirement for bit-reversed binary pixels within 32-bit words.</li><li>If the data is a region of interest within a larger image, then <code>pitch</code> &gt; <code>cols</code>, and this function should be called separately for each line in the region of interest.</li><li>Due to 3x3 filtering, the output will be shifted up one line, and left one pixel. This creates a 2 column border on the right edge, and the output is 2 lines smaller than the input (hence the requirement on max value of <code>cols</code> parameter above). The vertical shift can be avoided by passing pointer to the second row of output as the argument <code>out_data</code> to the function. Since the image is 32-bit backed binary data, horizontal shift cannot be avoided.</li><li>Border pixels will not contain valid data, in particular, the first and last row (if input and output are vertically aligned), and the two rightmost columns of the output do not contain valid data due to wraparound of the filtering on each line edge. See <a class="el" href="filter_shift.html">Output Shift by Filtering Functions</a> for more information.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Implementation Notes:</b></dt><dd><ul>
<li>This code is fully interruptible </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g35a51781a7f40ef91cf47a97c88b1065"></a><!-- doxytag: member="c66/VLIB_binarySkeleton.h::VLIB_binarySkeleton" ref="g35a51781a7f40ef91cf47a97c88b1065" args="(const uint32_t in_data[restrict], uint32_t out_data[restrict], uint32_t scratch[restrict], uint8_t mask[][VLIB_BINSKEL_MASK_SZ], uint8_t mask_d[][VLIB_BINSKEL_MASK_SZ], uint16_t width, uint16_t height, uint8_t num_st, uint8_t *iters)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VLIB_binarySkeleton           </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&nbsp;</td>
          <td class="paramname"> <em>in_data</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>out_data</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>scratch</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>mask</em>[][VLIB_BINSKEL_MASK_SZ], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>mask_d</em>[][VLIB_BINSKEL_MASK_SZ], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>num_st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>iters</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Description:</b></dt><dd>This function computes Binary Skeletonization (Thinning) using multiple iterations of hit-or-miss transform on 90 degree rotated versions of the given structural elements. It takes an array of programmable 3x3 masks (<code>mask</code>[][]) and their respective "don't care" masks (<code>mask_d</code>[][]). The number of masks that the <code>mask</code>[][] parameter points to is given by the <code>num_st</code> parameter.</dd></dl>
In binary skeletonization, a single 3x3 mask is represented by 1's (foreground), 0's (background), and X's (don't cares). This API uses two parameters to specify this information: <code>mask</code>[][] and <code>mask_d</code>[][]. The 1's and 0's locations in the mask are specified using the <code>mask</code>[][] parameter, and the X's (don't care) locations are specified by using 1 values in the <code>mask_d</code>[][] paramter, as shown below. <div class="fragment"><pre class="fragment">
    Example:
           1 0 1             1 0 1              0 0 0
     For:  X 1 X  :  mask =  0 1 0    mask_d =  1 0 1
           X 0 X             0 0 0              1 0 1
   </pre></div><p>
This function internally calls the <a class="el" href="group___v_l_i_b__binary_skeleton.html#g99d76dcbcd615f74b902c724bf247eea">VLIB_hitmiss_bin</a> function for each of the 4 orientations for each structuring element.<p>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>in_data[]</em>&nbsp;</td><td>Input image pointer (32-bit packed binary) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>out_data[]</em>&nbsp;</td><td>Output image pointer (32-bit packed binary) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scratch[]</em>&nbsp;</td><td>Scratch buffer (UQ8.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mask[][]</em>&nbsp;</td><td>Pointer to array of 3x3 structural element masks (UQ8.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mask_d[][]</em>&nbsp;</td><td>Pointer to array of 3x3 "don't care" masks (UQ8.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>width</em>&nbsp;</td><td>Width of the image (in terms of bits, since it is packed) (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>height</em>&nbsp;</td><td>Height of the image (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>num_st</em>&nbsp;</td><td>Number of 3x3 structural elements in mask array, must be &gt; 0. (UQ8.0) </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>iters</em>&nbsp;</td><td>As an input, this is the maximum number of iterations to run the algorithm. A value of 0 is the same as setting it to 255. This value will return the actual number of iterations run. (UQ8.0)</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Assumptions:</b></dt><dd><ul>
<li>The <code>in_data</code>, <code>out_data</code>, and <code>scratch</code> buffers are assumed to be 4 byte aligned and not aliased.</li><li>The <code>out_data</code> buffer should be at least the same size as the <code>in_data</code> buffer.</li><li>The <code>scratch</code> buffer should be the size as the <code>in_data</code> buffer plus 72*num_st bytes.</li><li>The input <code>width</code> must be a multiple of 32.</li><li>The result of <code>width</code> * <code>height:</code> <ul>
<li>must be &gt;= 128, and</li><li>must be multiples of 64,</li></ul>
</li><li>The bit-packed input and output are ordered the same way as pixels in the image. This is different from the IMGLIB requirement for bit-reversed binary pixels within 32-bit words.</li><li>Due to 3x3 filtering, the output will be shifted up one line, and left one pixel. This creates a 2 column border on the right edge, and the output is 2 lines smaller than the input (hence the requirement on max value of <code>cols</code> parameter above). The vertical shift can be avoided by passing pointer to the second row of output as the argument <code>out_data</code> to the function. Since the image is 32-bit backed binary data, horizontal shift cannot be avoided.</li><li>Border pixels of <code>out_data</code> will not contain valid data, in particular, the two rightmost columns of the output do not contain valid data. Additionally, the first and last row of <code>out_data</code> are never written to (if input and output are vertically aligned), so this should be considered during output buffer initialization, or downstream processing. See <a class="el" href="filter_shift.html">Output Shift by Filtering Functions</a> for more information.</li><li>The terminating condition for this function is = <a class="el" href="_v_l_i_b__orb_8h.html#3acffbd305ee72dcd4593c0d8af64a4f">MIN(iters, num_iters)</a>, where num_iters is the iteration number where the the output does not change from the previous iteration.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Implementation Notes:</b></dt><dd><ul>
<li>This code is fully interruptible </li></ul>
</dd></dl>

</div>
</div><p>
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
