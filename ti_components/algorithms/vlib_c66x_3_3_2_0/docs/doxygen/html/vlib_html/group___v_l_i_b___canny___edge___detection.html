<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>VLIB: VLIB_Canny_Edge_Detection</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>VLIB_Canny_Edge_Detection</h1><hr><a name="_details"></a><h2>Detailed Description</h2>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l_i_b___canny___edge___detection.html#gaad59a9a37ec6d6c5bb7402330f8e3cc">VLIB_Canny_Edge_Detection</a> (const uint8_t *pInput, int16_t *pBufGradX, int16_t *pBufGradY, int16_t *pBufMag, uint8_t *pBufOut, uint8_t *pScratch, int32_t *numItems, uint16_t width, uint16_t height)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l_i_b___canny___edge___detection.html#gbadb02fc6fc81c924cd7f81ee02237b4">VLIB_conv_7x7_i8_c8s</a> (const uint8_t *restrict imgin_ptr, uint8_t *restrict imgout_ptr, uint32_t width, int16_t pitch, const int8_t *restrict mask_ptr, int16_t shift)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l_i_b___canny___edge___detection.html#gbdbbcebaba2005f1b353524596e7efee">VLIB_nonMaximumSuppressionCanny</a> (const int16_t *restrict pInMag, const int16_t *restrict pInGradX, const int16_t *restrict pInGradY, uint8_t *restrict pOut, uint16_t width, uint16_t pitch, uint16_t height)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l_i_b___canny___edge___detection.html#g3deb120ba4579a21f0c23a145326c3c0">VLIB_doublethresholding</a> (const int16_t *restrict pInMag, uint8_t *edgeMap, uint32_t *restrict strongEdgeListPtr, int32_t *numStrongEdges, uint16_t width, uint16_t pitch, uint16_t height, uint8_t loThresh, uint8_t hiThresh, uint32_t pos_frm)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l_i_b___canny___edge___detection.html#g476f207a4067a98e76c105b51bf8110f">VLIB_edgeRelaxation</a> (uint8_t *edgeMap, uint32_t *restrict strongEdgeListPtr, const int32_t *numStrongEdges, uint16_t width)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gaad59a9a37ec6d6c5bb7402330f8e3cc"></a><!-- doxytag: member="c66/VLIB_Canny_Edge_Detection.h::VLIB_Canny_Edge_Detection" ref="gaad59a9a37ec6d6c5bb7402330f8e3cc" args="(const uint8_t *pInput, int16_t *pBufGradX, int16_t *pBufGradY, int16_t *pBufMag, uint8_t *pBufOut, uint8_t *pScratch, int32_t *numItems, uint16_t width, uint16_t height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VLIB_Canny_Edge_Detection           </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&nbsp;</td>
          <td class="paramname"> <em>pInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&nbsp;</td>
          <td class="paramname"> <em>pBufGradX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&nbsp;</td>
          <td class="paramname"> <em>pBufGradY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *&nbsp;</td>
          <td class="paramname"> <em>pBufMag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>pBufOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>pScratch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>numItems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Description:</b></dt><dd>This function is a wrapper function around the full Canny Edge Detection algorithms. It internally calls, in sequence on the image: <a class="el" href="group___v_l_i_b___canny___edge___detection.html#gbadb02fc6fc81c924cd7f81ee02237b4">VLIB_conv_7x7_i8_c8s</a> (image smoothing), <a class="el" href="group___v_l_i_b__xy_gradients_and_magnitude.html">VLIB_xyGradientsAndMagnitude</a>, <a class="el" href="group___v_l_i_b___canny___edge___detection.html#gbdbbcebaba2005f1b353524596e7efee">VLIB_nonMaximumSuppressionCanny</a>, <a class="el" href="group___v_l_i_b___canny___edge___detection.html#g3deb120ba4579a21f0c23a145326c3c0">VLIB_doublethresholding</a> and <a class="el" href="group___v_l_i_b___canny___edge___detection.html#g476f207a4067a98e76c105b51bf8110f">VLIB_edgeRelaxation</a>. It requires externally allocated intermediate buffers to be provided and takes care of border conditions in between internal function calls. The above mentioned APIs are independently callable in case a different sequence is required, intermeidate processing is required, or differ buffer management is required.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>*pInput</em>&nbsp;</td><td>Pointer to input image array </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>*pBufGradX</em>&nbsp;</td><td>Pointer to array containing X gradient </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>*pBufGradY</em>&nbsp;</td><td>Pointer to array containing Y gradient </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>*pBufMag</em>&nbsp;</td><td>Pointer to array containing magnitude </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>*pBufOut</em>&nbsp;</td><td>Pointer to output buffer </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>*pScratch</em>&nbsp;</td><td>Pointer to scratch buffer </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>*numItems</em>&nbsp;</td><td>Pointer to scalar number of items </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>width</em>&nbsp;</td><td>Input width </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>height</em>&nbsp;</td><td>Input height</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Assumptions:</b></dt><dd><ul>
<li>The input array and output arrays should not overlap</li><li>The output array must be 32-bit aligned</li><li>The width parameter must be a multiple of 2 and &gt;= 18</li><li>The height parameter must be &gt; 10</li><li>pBufGradX should be a buffer of (width * height * 2) bytes</li><li>pBufGradY should be a buffer of (width * height * 2) bytes</li><li>pBufMag should be a buffer of (width * height * 2) bytes</li><li>pBufOut should be a buffer of (width * height) bytes</li><li>pScratch should be a buffer of (width * height) bytes </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="gbadb02fc6fc81c924cd7f81ee02237b4"></a><!-- doxytag: member="c66/VLIB_Canny_Edge_Detection.h::VLIB_conv_7x7_i8_c8s" ref="gbadb02fc6fc81c924cd7f81ee02237b4" args="(const uint8_t *restrict imgin_ptr, uint8_t *restrict imgout_ptr, uint32_t width, int16_t pitch, const int8_t *restrict mask_ptr, int16_t shift)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VLIB_conv_7x7_i8_c8s           </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *restrict&nbsp;</td>
          <td class="paramname"> <em>imgin_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *restrict&nbsp;</td>
          <td class="paramname"> <em>imgout_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&nbsp;</td>
          <td class="paramname"> <em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t *restrict&nbsp;</td>
          <td class="paramname"> <em>mask_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&nbsp;</td>
          <td class="paramname"> <em>shift</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Description:</b></dt><dd>The convolution kernel accepts seven rows of 'pitch' input pixels and produces one row of 'width' output pixels using the 7 pixel square filter mask provided on input. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The input mask is rotated 180 degrees before passing it to the convolution kernel. The convolution sum is calculated as a point by point multiplication of the rotated mask with the input image. The 49 resulting multiplications are summed together to produce a 32-bit intermediate sum. Overflow during accumulation is not prevented, though assumptions may be applied to filter gain to avoid overflow. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>The user defined shift value is used to shift the convolution sum down to an 8-bit range prior to storing in the output array. The stored result is saturated as an unsigned 8-bit quantity. The mask is moved one column at a time, advancing the mask over the image until the entire 'width' is processed. </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>*imgin_ptr</em>&nbsp;</td><td>Pointer to an input image of 8-bit pixels </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>*imgout_ptr</em>&nbsp;</td><td>Pointer to an output image of 8-bit pixels </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>width</em>&nbsp;</td><td>Number of output pixels </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pitch</em>&nbsp;</td><td>Number of columns in the image </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>*mask_ptr</em>&nbsp;</td><td>Pointer to an 8-bit filter mask </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>shift</em>&nbsp;</td><td>User specified right shift on sum</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Assumptions:</b></dt><dd><ul>
<li>The input array and output array should not overlap</li><li>The output array must be 32-bit aligned</li><li>The width parameter must be a non-zero multiple of 2</li><li>The image pitch must be greater than or equal to the width</li><li>Due to wraparound of the filtering on each line edge, the function processes only valid non-border pixels of the input correctly and this results in the output being cropped to have only (input_width - 6) x (input_height - 6) valid pixels. Border thickness is three pixels as the window size used is 7x7. Also, as the first output pixel is obtained by processing the first valid non-border input pixel, there is a shift in the output image with respect to the input image. The shift is three pixels to the left and three pixels to the top. The shift can be avoided by passing the pointer to the fourth pixel of the fourth row of output as the argument <code>imgout_ptr</code> to the function. Since the output is cropped, its border pixels do not contain valid data. If the shift is avoided, the output border pixels are invalid. If the shift is not avoided, six rightmost columns and six bottommost rows of the output do not contain valid data. This output crop can be avoided by padding input and output borders with meaningful data, and passing the pointer offset of output to the function. See <a class="el" href="filter_shift.html">Output Shift by Filtering Functions</a> for more information.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Implementation Notes:</b></dt><dd><ul>
<li>This code is fully interruptible</li><li>This code is compatible with C66x processors </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="gbdbbcebaba2005f1b353524596e7efee"></a><!-- doxytag: member="c66/VLIB_Canny_Edge_Detection.h::VLIB_nonMaximumSuppressionCanny" ref="gbdbbcebaba2005f1b353524596e7efee" args="(const int16_t *restrict pInMag, const int16_t *restrict pInGradX, const int16_t *restrict pInGradY, uint8_t *restrict pOut, uint16_t width, uint16_t pitch, uint16_t height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t VLIB_nonMaximumSuppressionCanny           </td>
          <td>(</td>
          <td class="paramtype">const int16_t *restrict&nbsp;</td>
          <td class="paramname"> <em>pInMag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t *restrict&nbsp;</td>
          <td class="paramname"> <em>pInGradX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int16_t *restrict&nbsp;</td>
          <td class="paramname"> <em>pInGradY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *restrict&nbsp;</td>
          <td class="paramname"> <em>pOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Description:</b></dt><dd>As the third stage in Canny Edge Detection, non-maximum suppression identifies potential edge pixels. It suppresses all pixels whose edge strength is not a local maximum along the gradient direction.</dd></dl>
<dl class="user" compact><dt><b>Method:</b></dt><dd>Creates an 8-bit edge map labeling each pixel location as a non-Edge (0) or possible-edge (127). For each pixel location, the gradient direction is established. Two virtual points, say at a and b lying along the gradient direction on either side of the current location c are interpolated using the gradient magnitudes from surrounding neighbors. Locations that achieve a local maximum are regarded as possible edges, such as, Gmag(c) &gt; Gmag(a) AND Gmag(c) &gt;= Gmag(b); otherwise, these points are declared non-edges.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>*pInMag</em>&nbsp;</td><td>Pointer to array containing magnitude </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>*pInGradX</em>&nbsp;</td><td>Pointer to array containing X gradient </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>*pInGradY</em>&nbsp;</td><td>Pointer to array containing Y gradient </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>*pOut</em>&nbsp;</td><td>Pointer to output data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>width</em>&nbsp;</td><td>Input width </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pitch</em>&nbsp;</td><td>Input pitch </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>height</em>&nbsp;</td><td>input height</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Assumptions:</b></dt><dd><ul>
<li>This function uses a 3x3 kernel and operates on rows instead of pixels. The function accepts 3 rows of input (Gx, Gy and Gmag) for every single row of the edge map that is calculated. This function introduces another 1-pixel border of invalid data around the center-portion of the edge map. The input pointers should be the top left corner of the image where the processing starts. Take care in adjusting the pointers according to the filter used for convolution.</li><li>The width should be a multiple of 2 and &gt;= 10 </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g3deb120ba4579a21f0c23a145326c3c0"></a><!-- doxytag: member="c66/VLIB_Canny_Edge_Detection.h::VLIB_doublethresholding" ref="g3deb120ba4579a21f0c23a145326c3c0" args="(const int16_t *restrict pInMag, uint8_t *edgeMap, uint32_t *restrict strongEdgeListPtr, int32_t *numStrongEdges, uint16_t width, uint16_t pitch, uint16_t height, uint8_t loThresh, uint8_t hiThresh, uint32_t pos_frm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t VLIB_doublethresholding           </td>
          <td>(</td>
          <td class="paramtype">const int16_t *restrict&nbsp;</td>
          <td class="paramname"> <em>pInMag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>edgeMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *restrict&nbsp;</td>
          <td class="paramname"> <em>strongEdgeListPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>numStrongEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>pitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>loThresh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>hiThresh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>pos_frm</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Description:</b></dt><dd>Hysteresis thresholding is the final stage within Canny edge detection. With an edge map containing possible edges, hysteresis thresholding identifies and follows edges. Using both High and Low thresholds, it is able to maintain edge continuity by linking stronger edge segments that are connected to weaker segments. This stage is split into two functions <a class="el" href="group___v_l_i_b___canny___edge___detection.html#g3deb120ba4579a21f0c23a145326c3c0">VLIB_doublethresholding</a> (block based) and <a class="el" href="group___v_l_i_b___canny___edge___detection.html#g476f207a4067a98e76c105b51bf8110f">VLIB_edgeRelaxation</a> (Non block based). </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>This function is block based, and implements the first stage of hysteresis thresholding.</dd></dl>
<dl class="user" compact><dt><b>Method:</b></dt><dd>This function accepts an edge map, with each location labeled with values of either 0 (non-edge) or 127 (possible-edge). It searches for locations where the magnitude is at or above the high threshold. Values in the edge map are modified from possible-edge (127) to edge (255) for line segments.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>*pInMag</em>&nbsp;</td><td>Pointer to array containing magnitude </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>*edgeMap</em>&nbsp;</td><td>Pointer to array Edge map </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>*strongEdgeListPtr</em>&nbsp;</td><td>Pointer to array strong edge list </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>*numStrongEdges</em>&nbsp;</td><td>Number of edges in strongEdgeListPtr arrray </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>width</em>&nbsp;</td><td>Input width </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pitch</em>&nbsp;</td><td>Input pitch </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>height</em>&nbsp;</td><td>Input height </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>loThresh</em>&nbsp;</td><td>Lower threshold </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hiThresh</em>&nbsp;</td><td>Upper thershold </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pos_frm</em>&nbsp;</td><td>Position offset within the frame that pInMag and edgeMap are pointing to</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Assumptions:</b></dt><dd><ul>
<li>The size of the strongEdgeListPtr is content dependent, but at its largest, should be large enough to store 32-bit representation for each edge pixel in the entire image.</li><li>This function is called before <a class="el" href="group___v_l_i_b___canny___edge___detection.html#g476f207a4067a98e76c105b51bf8110f">VLIB_edgeRelaxation</a>. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="g476f207a4067a98e76c105b51bf8110f"></a><!-- doxytag: member="c66/VLIB_Canny_Edge_Detection.h::VLIB_edgeRelaxation" ref="g476f207a4067a98e76c105b51bf8110f" args="(uint8_t *edgeMap, uint32_t *restrict strongEdgeListPtr, const int32_t *numStrongEdges, uint16_t width)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t VLIB_edgeRelaxation           </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>edgeMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *restrict&nbsp;</td>
          <td class="paramname"> <em>strongEdgeListPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t *&nbsp;</td>
          <td class="paramname"> <em>numStrongEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>width</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Description:</b></dt><dd>Hysteresis thresholding is the final stage within Canny edge detection. With an edge map containing possible edges, hysteresis thresholding identifies and follows edges. Using both High and Low thresholds, it is able to maintain edge continuity by linking stronger edge segments that are connected to weaker segments. This stage is split into two functions <a class="el" href="group___v_l_i_b___canny___edge___detection.html#g3deb120ba4579a21f0c23a145326c3c0">VLIB_doublethresholding</a> (block based) and <a class="el" href="group___v_l_i_b___canny___edge___detection.html#g476f207a4067a98e76c105b51bf8110f">VLIB_edgeRelaxation</a> (Non block based). </dd></dl>
<dl class="user" compact><dt><b></b></dt><dd>This function is non block based, and implements the second stage of hysteresis thresholding.</dd></dl>
<dl class="user" compact><dt><b>Method:</b></dt><dd>This function grows the edge segments by following a path of connected edges with magnitude values at or above the low threshold. Values in the edge map are modified from possible-edge (127) to edge (255) for line segments.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>*edgeMap</em>&nbsp;</td><td>Pointer to array Edge map </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>*strongEdgeListPtr</em>&nbsp;</td><td>Pointer to array strong edge list </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>*numStrongEdges</em>&nbsp;</td><td>Number of edges in strongEdgeListPtr arrray </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>width</em>&nbsp;</td><td>Input width</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Assumptions:</b></dt><dd><ul>
<li>This function is called after <a class="el" href="group___v_l_i_b___canny___edge___detection.html#g3deb120ba4579a21f0c23a145326c3c0">VLIB_doublethresholding</a>.</li><li>The size of the strongEdgeListPtr is content dependent, but at its largest, should be large enough to store 32-bit representation for each edge pixel in the entire image.</li><li>If an edge map is desired that only consists of non-edges (0) and edges (255), it will be necessary to remove the remaining possible-edges (127) after this function completes. Edge linking is image content dependent. This function is generally frame-based, so it can be difficult to partition this function into sub-image blocks, especially for large images. Use caution when locating the strongEdgeListPtr buffer in fast memory areas (L1D/L2D). </li></ul>
</dd></dl>

</div>
</div><p>
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
