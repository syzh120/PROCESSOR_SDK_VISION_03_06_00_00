<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>VLIB: VLIB_grayscale_morphology</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>VLIB_grayscale_morphology</h1><hr><a name="_details"></a><h2>Detailed Description</h2>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l_i_b__grayscale__morphology.html#g1ea026d85edac59ec1a8a1af473aa482">VLIB_grayscale_morphology</a> (uint16_t blk_w, uint16_t line_ofst, uint16_t blk_h, const uint8_t data_ptr[], uint16_t se_w, uint16_t se_h, const uint8_t se_ptr[], const uint8_t refl_se_ptr[], uint8_t scratch1_ptr[], uint8_t scratch2_ptr[], uint8_t output_ptr[], uint8_t operation)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l_i_b__grayscale__morphology.html#g0050bcda5447861d21db8223b32ff155">VLIB_grayscale_dilate_mask</a> (uint16_t blk_w, uint16_t line_ofst, uint16_t blk_h, const uint8_t data_ptr[restrict], uint16_t se_w, uint16_t se_h, const uint8_t se_ptr[restrict], uint8_t scratchBuf[restrict], uint8_t output_ptr[restrict])</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l_i_b__grayscale__morphology.html#gedabb9a97a14767dfb0edc28a959a066">VLIB_grayscale_morp_diff</a> (uint16_t blk_w, uint16_t line_ofst, uint16_t blk_h, const uint8_t data_ptr[restrict], const uint8_t data2_ptr[restrict], const uint8_t output_ptr[restrict])</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l_i_b__grayscale__morphology.html#gc222f21daf548b245db156104cc8dbe0">VLIB_grayscale_gradient_mask</a> (uint16_t blk_w, uint16_t line_ofst, uint16_t blk_h, const uint8_t data_ptr[restrict], uint16_t se_w, uint16_t se_h, const uint8_t se_ptr[restrict], const uint8_t refl_se_ptr[restrict], uint8_t scratchBuf[restrict], uint8_t output_ptr[restrict])</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l_i_b__grayscale__morphology.html#g1bc7d8c8007adbeefe87618d730307dc">VLIB_grayscale_erode_mask</a> (uint16_t blk_w, uint16_t line_ofst, uint16_t blk_h, const uint8_t data_ptr[restrict], uint16_t se_w, uint16_t se_h, const uint8_t se_ptr[restrict], uint8_t scratchBuf[restrict], uint8_t output_ptr[restrict])</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g1ea026d85edac59ec1a8a1af473aa482"></a><!-- doxytag: member="c66/VLIB_grayscale_morphology.h::VLIB_grayscale_morphology" ref="g1ea026d85edac59ec1a8a1af473aa482" args="(uint16_t blk_w, uint16_t line_ofst, uint16_t blk_h, const uint8_t data_ptr[], uint16_t se_w, uint16_t se_h, const uint8_t se_ptr[], const uint8_t refl_se_ptr[], uint8_t scratch1_ptr[], uint8_t scratch2_ptr[], uint8_t output_ptr[], uint8_t operation)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VLIB_grayscale_morphology           </td>
          <td>(</td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>blk_w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>line_ofst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>blk_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>data_ptr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>se_w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>se_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>se_ptr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>refl_se_ptr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>scratch1_ptr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>scratch2_ptr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>output_ptr</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>operation</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Description:</b></dt><dd>This is a wrapper function that internally calls one of the grayscale morphology operations depending on the <code>operation</code> parameter being set to one of the options listed in <a class="el" href="_v_l_i_b__grayscale__morphology__types_8h.html#6754e85a980f18d2eb218a03d1dab6bd">GrayscaleMorphologyOperation</a>.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>blk_w</em>&nbsp;</td><td>width of input block, in elements (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>line_ofst</em>&nbsp;</td><td>offset between input lines, in elements (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>blk_h</em>&nbsp;</td><td>height of input block (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data_ptr[]</em>&nbsp;</td><td>input data pointer (UQ8.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>se_w</em>&nbsp;</td><td>width of structuring element block, in elements (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>se_h</em>&nbsp;</td><td>height of structuring element block (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>se_ptr[]</em>&nbsp;</td><td>structuring element data pointer (UQ8.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refl_se_ptr[]</em>&nbsp;</td><td>Reflected structuring element data pointer (UQ8.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scratch1_ptr[]</em>&nbsp;</td><td>scratch 1 pointer. Size of this scratch buffer should be equal to input image size (UQ8.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scratch2_ptr[]</em>&nbsp;</td><td>scratch 2 pointer. This scratch buffer is for temproray data storage and it is used only when se_h =1, and all the elements of structuring element is one and (blk_h - (se_h-1))se_h = 0. Size of this buffer should be 32*se_h (UQ8.0) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>output_ptr[]</em>&nbsp;</td><td>output data pointer (UQ8.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>operation</em>&nbsp;</td><td>Operation selection <a class="el" href="_v_l_i_b__grayscale__morphology__types_8h.html#6754e85a980f18d2eb218a03d1dab6bd">GrayscaleMorphologyOperation</a> (UQ8.0)</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Assumptions:</b></dt><dd><ul>
<li>For this API 'se_w' and 'se_h' both should be any odd positive number and one of them should be greater than or equal to 3.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Implementation Notes:</b></dt><dd><ul>
<li>This code is fully interruptible</li><li>This code is compatible with C6XXX fixed and floating point processors</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Benchmarks:</b></dt><dd>See VLIB_Test_Report.html for cycle and memory information. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g0050bcda5447861d21db8223b32ff155"></a><!-- doxytag: member="c66/VLIB_grayscale_morphology.h::VLIB_grayscale_dilate_mask" ref="g0050bcda5447861d21db8223b32ff155" args="(uint16_t blk_w, uint16_t line_ofst, uint16_t blk_h, const uint8_t data_ptr[restrict], uint16_t se_w, uint16_t se_h, const uint8_t se_ptr[restrict], uint8_t scratchBuf[restrict], uint8_t output_ptr[restrict])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VLIB_grayscale_dilate_mask           </td>
          <td>(</td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>blk_w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>line_ofst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>blk_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>data_ptr</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>se_w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>se_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>se_ptr</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>scratchBuf</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>output_ptr</em>[restrict]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Description:</b></dt><dd>Performs grayscale dilation of an 8-bit grayscale input image at data_ptr, of size blk_w by blk_h, with a flat structuring element of size se_w by se_h, specified with a mask of 1's and 0's at se_ptr. The dilation operator considers only the non zero values of input mask, and finds the maximum of all corresponding input pixels under the mask which is the value of output pixel at the location of the center pixel of the mask. The output is written into output_ptr. This API internally calls other specific API's suited for specific sizes. <div class="fragment"><pre class="fragment">
    Example:
    For the mask
    0 1 0
    1 1 1
    0 1 0

    The output pixel is the maximum of input (center) pixel, its north, east, west and south neighbors.
   </pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>blk_w</em>&nbsp;</td><td>width of input block, in elements (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>line_ofst</em>&nbsp;</td><td>offset between input lines, in elements (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>blk_h</em>&nbsp;</td><td>height of input block (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data_ptr[]</em>&nbsp;</td><td>input data pointer (UQ8.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>se_w</em>&nbsp;</td><td>width of structuring element block, in elements (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>se_h</em>&nbsp;</td><td>height of structuring element block (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>se_ptr[]</em>&nbsp;</td><td>structuring element data pointer (UQ8.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scratchBuf[]</em>&nbsp;</td><td>scratch buffer for temproray data storage and it is used only when se_h=1, and all the elements of structuring element are one and (blk_h - (se_h-1))se_h = 0. Size of this buffer should be 32*se_h (UQ8.0) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>output_ptr[]</em>&nbsp;</td><td>output data pointer (UQ8.0)</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Assumptions:</b></dt><dd><ul>
<li>For this API 'se_w' and 'se_h' both should be any odd positive number and one of them should be greater than or equal to 3.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Implementation Notes:</b></dt><dd><ul>
<li>This code is fully interruptible</li><li>This code is compatible with C6XXX fixed and floating point processors</li><li>For Mx1 structuring elements where all the elements are '1', better performance number can be achieved if (blk_h - (se_h-1))se_h = 0. To satisfy this condition extra dummy rows can be provided along with input image.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Benchmarks:</b></dt><dd>See VLIB_Test_Report.html for cycle and memory information. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gedabb9a97a14767dfb0edc28a959a066"></a><!-- doxytag: member="c66/VLIB_grayscale_morphology.h::VLIB_grayscale_morp_diff" ref="gedabb9a97a14767dfb0edc28a959a066" args="(uint16_t blk_w, uint16_t line_ofst, uint16_t blk_h, const uint8_t data_ptr[restrict], const uint8_t data2_ptr[restrict], const uint8_t output_ptr[restrict])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VLIB_grayscale_morp_diff           </td>
          <td>(</td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>blk_w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>line_ofst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>blk_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>data_ptr</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>data2_ptr</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>output_ptr</em>[restrict]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Description:</b></dt><dd>Performs image difference operation between two 8-bit gray- scale images at data_ptr and data2_ptr, both of size blk_w by blk_h, and writes the output into output_ptr. The function assumes that the image pixel values at data_ptr is greater than the corresponding pixel values at data2_ptr. Also it has been assumed that subtraction results fits in 8 bit.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>blk_w</em>&nbsp;</td><td>width of input block, in elements (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>line_ofst</em>&nbsp;</td><td>offset between input lines, in elements (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>blk_h</em>&nbsp;</td><td>height of input block (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data_ptr[]</em>&nbsp;</td><td>input 1 data pointer (UQ8.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data2_ptr[]</em>&nbsp;</td><td>input 2 data pointer (UQ8.0) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>output_ptr[]</em>&nbsp;</td><td>output data pointer (UQ8.0)</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Implementation Notes:</b></dt><dd><ul>
<li>This code is fully interruptible</li><li>This code is compatible with C6XXX fixed and floating point processors</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Benchmarks:</b></dt><dd>See VLIB_Test_Report.html for cycle and memory information. </dd></dl>

</div>
</div><p>
<a class="anchor" name="gc222f21daf548b245db156104cc8dbe0"></a><!-- doxytag: member="c66/VLIB_grayscale_morphology.h::VLIB_grayscale_gradient_mask" ref="gc222f21daf548b245db156104cc8dbe0" args="(uint16_t blk_w, uint16_t line_ofst, uint16_t blk_h, const uint8_t data_ptr[restrict], uint16_t se_w, uint16_t se_h, const uint8_t se_ptr[restrict], const uint8_t refl_se_ptr[restrict], uint8_t scratchBuf[restrict], uint8_t output_ptr[restrict])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VLIB_grayscale_gradient_mask           </td>
          <td>(</td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>blk_w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>line_ofst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>blk_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>data_ptr</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>se_w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>se_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>se_ptr</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>refl_se_ptr</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>scratchBuf</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>output_ptr</em>[restrict]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Description:</b></dt><dd>Performs image gradient operation by finding the difference between the dilated and eroded input image, both of size blk_w by blk_h, and writes the output into output_ptr. The function assumes that the image pixel values in dilated image is greater than the corresponding pixel values in eroded image.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>blk_w</em>&nbsp;</td><td>width of input block, in elements (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>line_ofst</em>&nbsp;</td><td>offset between input lines, in elements (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>blk_h</em>&nbsp;</td><td>height of input block (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data_ptr[]</em>&nbsp;</td><td>input data pointer (UQ8.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>se_w</em>&nbsp;</td><td>width of structuring element block, in elements (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>se_h</em>&nbsp;</td><td>height of structuring element block (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>se_ptr[]</em>&nbsp;</td><td>structuring element data pointer (UQ8.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>refl_se_ptr[]</em>&nbsp;</td><td>Reflected structuring element data pointer (UQ8.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scratchBuf[]</em>&nbsp;</td><td>scratch Buffer for temproray data storage and it is used only when se_h=1, and all the elements of structuring element is one and (blk_h - (se_h-1))se_h = 0. Size of this buffer should be 32*se_h (UQ8.0) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>output_ptr[]</em>&nbsp;</td><td>output data pointer (UQ8.0)</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Assumptions:</b></dt><dd><ul>
<li>For this API se_w and se_h both should odd positive number and one of them should be greater than equal to 3. </li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Implementation Notes:</b></dt><dd><ul>
<li>This code is fully interruptible</li><li>This code is compatible with C6XXX fixed and floating point processors</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Benchmarks:</b></dt><dd>See VLIB_Test_Report.html for cycle and memory information. </dd></dl>

</div>
</div><p>
<a class="anchor" name="g1bc7d8c8007adbeefe87618d730307dc"></a><!-- doxytag: member="c66/VLIB_grayscale_morphology.h::VLIB_grayscale_erode_mask" ref="g1bc7d8c8007adbeefe87618d730307dc" args="(uint16_t blk_w, uint16_t line_ofst, uint16_t blk_h, const uint8_t data_ptr[restrict], uint16_t se_w, uint16_t se_h, const uint8_t se_ptr[restrict], uint8_t scratchBuf[restrict], uint8_t output_ptr[restrict])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void VLIB_grayscale_erode_mask           </td>
          <td>(</td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>blk_w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>line_ofst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>blk_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>data_ptr</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>se_w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>se_h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>se_ptr</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>scratchBuf</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>output_ptr</em>[restrict]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Description:</b></dt><dd>Performs grayscale erosion of an 8-bit grayscale input image at data_ptr, of size blk_w by blk_h, with a flat structuring element of size se_w by se_h, specified with a mask of 1's and 0's at se_ptr. The erosion operator considers only the non zero values of input mask, and finds the minimum of all corresponding input pixels under the mask which is the value of output pixel at the location of the center pixel of the mask. The output is written into output_ptr. <div class="fragment"><pre class="fragment">
    Example:
    For the mask
    0 1 0
    1 1 1
    0 1 0

    The output pixel is the minimum of input (center) pixel, its north, east, west and south neighbors.
   </pre></div></dd></dl>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>blk_w</em>&nbsp;</td><td>width of input block, in elements (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>line_ofst</em>&nbsp;</td><td>offset between input lines, in elements (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>blk_h</em>&nbsp;</td><td>height of input block (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data_ptr[]</em>&nbsp;</td><td>input data pointer (UQ8.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>se_w</em>&nbsp;</td><td>width of structuring element block, in elements (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>se_h</em>&nbsp;</td><td>height of structuring element block (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>se_ptr[]</em>&nbsp;</td><td>structuring element data pointer (UQ8.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scratchBuf[]</em>&nbsp;</td><td>scratch Buffer for temproray data storage and it is used only when se_h=1, and all the elements of structuring element is one and (blk_h - (se_h-1))se_h = 0. Size of this buffer should be 32*se_h (UQ8.0)</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>output_ptr[]</em>&nbsp;</td><td>output data pointer (UQ8.0)</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Assumptions:</b></dt><dd><ul>
<li>For this API 'se_w' and 'se_h' both should be any odd positive number and one of them should be greater than or equal to 3.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Implementation Notes:</b></dt><dd><ul>
<li>This code is fully interruptible</li><li>This code is compatible with C6XXX floating point processors</li><li>For Mx1 structuring elements where all the elements are '1', better performance number can be achieved if (blk_h - (se_h-1))se_h = 0. To satisfy this condition extra dummy rows can be provided along with input image.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Benchmarks:</b></dt><dd>See VLIB_Test_Report.html for cycle and memory information. </dd></dl>

</div>
</div><p>
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
