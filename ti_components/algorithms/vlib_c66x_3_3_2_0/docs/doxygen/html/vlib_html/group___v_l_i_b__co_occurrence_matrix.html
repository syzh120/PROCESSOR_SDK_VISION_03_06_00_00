<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>VLIB: VLIB_coOccurrenceMatrix</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>VLIB_coOccurrenceMatrix</h1><hr><a name="_details"></a><h2>Detailed Description</h2>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l_i_b__co_occurrence_matrix.html#gf84ae5763c4b517867a9b5a72245250d">VLIB_coOccurrenceMatrix</a> (const uint8_t pInput[restrict], uint16_t *restrict pCoMatrix[], const uint16_t imageWidth, const uint16_t imageHeight, const uint16_t imagePitch, const uint8_t loPixelVal, const uint8_t hiPixelVal, const uint16_t numLevels, const uint8_t numOffsets, const int8_t rowOffsets[restrict], const int8_t colOffsets[restrict], uint8_t *scratch)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gf84ae5763c4b517867a9b5a72245250d"></a><!-- doxytag: member="c66/VLIB_coOccurrenceMatrix.h::VLIB_coOccurrenceMatrix" ref="gf84ae5763c4b517867a9b5a72245250d" args="(const uint8_t pInput[restrict], uint16_t *restrict pCoMatrix[], const uint16_t imageWidth, const uint16_t imageHeight, const uint16_t imagePitch, const uint8_t loPixelVal, const uint8_t hiPixelVal, const uint16_t numLevels, const uint8_t numOffsets, const int8_t rowOffsets[restrict], const int8_t colOffsets[restrict], uint8_t *scratch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t VLIB_coOccurrenceMatrix           </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>pInput</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *restrict&nbsp;</td>
          <td class="paramname"> <em>pCoMatrix</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&nbsp;</td>
          <td class="paramname"> <em>imageWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&nbsp;</td>
          <td class="paramname"> <em>imageHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&nbsp;</td>
          <td class="paramname"> <em>imagePitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>loPixelVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>hiPixelVal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint16_t&nbsp;</td>
          <td class="paramname"> <em>numLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>numOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t&nbsp;</td>
          <td class="paramname"> <em>rowOffsets</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int8_t&nbsp;</td>
          <td class="paramname"> <em>colOffsets</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>scratch</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Description:</b></dt><dd>This routine accepts an 8-bit grayscale input image of size imageWidth by imageHeight with a stride of imagePitch and calculates gray scale co-occurrence for multiple angles. Angles are taken in terms of offsets in row and columns. E.g. rowOffset = -D and colOffset = D indicates pixel at 45 degree down from current pixel. In single call of this API output matrix can be calculated for multiple offsets ( or angles).</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pInput[]</em>&nbsp;</td><td>input data pointer (UQ8.0 ) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pCoMatrix[]</em>&nbsp;</td><td>Array of pointers for output matrices (UQ16.0*) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>imageWidth</em>&nbsp;</td><td>width of input data, in elements (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>imageHeight</em>&nbsp;</td><td>height of input data, in elements (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>imagePitch</em>&nbsp;</td><td>stride between input lines, in elements (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>loPixelVal</em>&nbsp;</td><td>Input values less than or equal to lowPixelVal (UQ8.0 ) are scaled to 0. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>hiPixelVal</em>&nbsp;</td><td>Input values more than or equal to hiPixelVal (UQ8.0 ) are scaled to (numLevels -1). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numLevels</em>&nbsp;</td><td>The range [lowPixelVal hiPixelVal] is divided (UQ16.0 ) into numLevels equal width bins and values in a bin get mapped to a single gray level. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numOffsets</em>&nbsp;</td><td>Number of directions for which out matrix is (UQ8.0 ) needed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rowOffsets</em>&nbsp;</td><td>Pointer for the offsets in Y direction for pixel (SQ8.0 ) in interest and neighbour pixel. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>colOffsets</em>&nbsp;</td><td>Pointer for the offsets in X direction for pixel (SQ8.0 ) in interest and neighbour pixel. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>scratch</em>&nbsp;</td><td>Pointer to scratch area. This is not mandatory (UQ8.0* ) input.Application can provide this value as NULL, if scratch memory can not be provided. Cycle consumed will be lesser when scratch buffer is provided. Scratch buffer size need to be 8*numLevels*numLevels, when it is provided. API checks the value of this argument against NULL, and accordingly appropriate flow chosen.</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Assumptions:</b></dt><dd><ul>
<li>Input image data is of 8 bits.</li><li>Output data is saturated to 16 bits</li><li>I/O buffers are assumed to be not aliased.</li><li>Scratch buffer <code>scratch</code> should be 8-byte aligned in memory.</li><li>Active width (imageWidth - abs(colOffset)) should be at least 16 pixels</li><li>output buffer and scratch buffers are internally cleared to zero</li><li>loPixelVal value should be less than hiPixelVal</li><li>numLevels should be within the range [2 .. 256]</li><li>numLevels should be less than or equal hiPixelVal - loPixelVal + 1</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Implementation Notes:</b></dt><dd><ul>
<li>There are two optimization flows have been implemented for this kernel. These two flow can be selected by: 1: passing a valid scratch buffer or 2: passing a NULL (0) pointer as the scratch buffer pointer Optimization flow with scratch buffer will have faster performance. Also if (hiPixelValue-loPixelValue+1)/numLevels is a positive power of two AND numLevels&lt;=64 then LUT usage while binning the pixels can be avoided which will give further performance improvement when the scratch buffer is passed.</li><li>For lower image size, non scratch flow will give better cycle performance number.</li><li>For larger image size , scratch buffer flow will give better cycle performance number.</li><li>In scratch buffer flow, 4 temporary histograms are used which needs to be reset to zero internally. </li></ul>
</dd></dl>

</div>
</div><p>
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
