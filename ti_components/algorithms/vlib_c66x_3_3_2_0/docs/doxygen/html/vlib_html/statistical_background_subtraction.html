<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>VLIB: Statistical Background Subtraction</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="index.html">VLIB Function Reference</a></div>
<h1><a class="anchor" name="statistical_background_subtraction">Statistical Background Subtraction</a></h1><h2><a class="anchor" name="intro5">
Introduction and Use Cases</a></h2>
In background subtraction, thresholding can be used to decide whether a pixels observed value deviates too far from its model (that is, the average of its past values). Assuming each pixels variance has been modeled, one might threshold a deviation image with a (scaled) variance image.<h2><a class="anchor" name="specification5">
Specification</a></h2>
<h3><a class="anchor" name="function5">
Function</a></h3>
This function implements a statistical background segmentation algorithm.<h3><a class="anchor" name="variants5">
Variants</a></h3>
This functionality is available in two variants: 16-bit and 32-bit<h3><a class="anchor" name="input5">
Inputs</a></h3>
<div class="fragment"><pre class="fragment">

    Parameter          Description                                     16-bit           32-bit
    -------------------------------------------------------------------------------------------
    *mask32packed      Binary mask to be computed                     (32-bit packed)  (32-bit packed)
    *newLuma           Most recent Luma buffer                        (UQ8.0)          (UQ8.0)
    *runningMean       Exponentially weighted running mean buffer     (SQ8.7)          (SQ8.23)
    *runningVar        Exponentially weighted running variance buffer (SQ12.3)         (SQ16.15)
     thresholdGlobal   Global threshold value                         (SQ12.3)         (SQ16.15)
     thresholdFactor   Multiplicative factor for threshold            (SQ4.11)         (SQ4.27)
     PixelCount        Number of pixels to process                    (UQ32.0)         (UQ32.0)
   </pre></div><h3><a class="anchor" name="outputs5">
Outputs</a></h3>
<div class="fragment"><pre class="fragment">
    Returns VLIB Error Status
</pre></div> <h3><a class="anchor" name="method5">
Method</a></h3>
For each pixel, the running mean and variance statistics are assumed to be known. The routine makes comparisons between three scalar values for each pixel:<ol type=1>
<li>The squared distance between the most recent luma measurement and the running mean determined by the following equation: <div class="fragment"><pre class="fragment">
    (newLuma - runningMean)^2
</pre></div></li><li>The thresholdGlobal</li><li>thresholdFactor x runningVar</li></ol>
<p>
For a pixel to be classified as foreground, (1) needs to be greater than both (2) and (3). When these conditions are satisfied, the observation is deemed to stem from a foreground object (and not from the modeled background), and the corresponding mask pixel value is set to 1.<p>
The comparison with (2) plays the role of assuming a minimum variance for the pixel values, as in camera noise, etc. A sequence of luma observations might be very consistent, driving the running variance to small values. In such cases, camera noise could cause a pixel to pass the foreground threshold. By setting a reasonably high camera noise value (which is a "squared" scalar), one can filter out the camera noise.<p>
Note that the thresholdFactor is also in <em>squared</em> form: if you would like measurements which are 2 standard deviations away from the mean to be classified as foreground, the thresholdFactor should be set to 2x2=4. For 16 bit, this variable is represented as SQ4.11 (sign bit, integer bits, 11 fractional bits). In hex-format, 4(dec) would read 0x2000. For 32 bit, this variable is represented as SQ4.27 (sign bit, 4 integer bits, 27 fractional bits). In hex-format, 4(dec) would read 0x20000000.<h3><a class="anchor" name="apis5">
APIS</a></h3>
S16 Variant<ul>
<li><a class="el" href="group___v_l_i_b__subtract_background_s16.html">VLIB_subtractBackgroundS16</a></li><li><a class="el" href="group___v_l_i_b__init_mean_with_luma_s16.html">VLIB_initMeanWithLumaS16</a></li><li><a class="el" href="group___v_l_i_b__init_var_with_const_s16.html">VLIB_initVarWithConstS16</a></li></ul>
<p>
S32 Variant<ul>
<li><a class="el" href="group___v_l_i_b__subtract_background_s32.html">VLIB_subtractBackgroundS32</a></li><li><a class="el" href="group___v_l_i_b__init_mean_with_luma_s32.html">VLIB_initMeanWithLumaS32</a></li><li><a class="el" href="group___v_l_i_b__init_var_with_const_s32.html">VLIB_initVarWithConstS32</a></li></ul>
<h2><a class="anchor" name="notes5">
Notes</a></h2>
<ul>
<li>I/O buffers are assumed to be double-word aligned in memory.</li><li>pixelCount must be a multiple of 8. </li></ul>
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
