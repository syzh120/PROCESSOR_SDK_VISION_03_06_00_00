<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>VLIB: VLIB_xyGradients</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>VLIB_xyGradients</h1><hr><a name="_details"></a><h2>Detailed Description</h2>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l_i_b__xy_gradients.html#gc39884324db0d8f20fc3b63b23ce690e">VLIB_xyGradients</a> (const uint8_t *restrict pIn, int16_t *restrict pGradX, int16_t *restrict pGradY, uint16_t width, uint16_t height)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gc39884324db0d8f20fc3b63b23ce690e"></a><!-- doxytag: member="c66/VLIB_xyGradients.h::VLIB_xyGradients" ref="gc39884324db0d8f20fc3b63b23ce690e" args="(const uint8_t *restrict pIn, int16_t *restrict pGradX, int16_t *restrict pGradY, uint16_t width, uint16_t height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t VLIB_xyGradients           </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *restrict&nbsp;</td>
          <td class="paramname"> <em>pIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *restrict&nbsp;</td>
          <td class="paramname"> <em>pGradX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *restrict&nbsp;</td>
          <td class="paramname"> <em>pGradY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Description:</b></dt><dd>For each pixel in the image, this function extracts the horizontal and vertical 1st order gradients. This is the same functionality as the <a class="el" href="group___v_l_i_b__xy_gradients_and_magnitude.html">VLIB_xyGradientsAndMagnitude</a> except the magnitude extraction has been removed to improve performance in applications which do not need magnitude values. Gradients are 2D vectors which point in the direction of the greatest rate of change, in this case, in intensity. This function extracts the 2D gradient vector coordinates.</dd></dl>
<dl class="user" compact><dt><b>Method:</b></dt><dd>The first order 3x3 gradient filter calculates the first derivative in both the horizontal and vertical directions, Gx and Gy, respectively. So for the image pixel I(x,y), we calculate the gradients as shown in the following equations:</dd></dl>
<div class="fragment"><pre class="fragment">

    Gx = I(x+1,y) - I(x-1,y)
    Gy = I(x,y+1) - I(x,y-1)

    Gx and Gy are both signed, 16-bit values.
   </pre></div><p>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>*pIn</em>&nbsp;</td><td>Pointer to array containing input image (UQ8.0) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>*pGradX</em>&nbsp;</td><td>Pointer to array containing X gradient (SQ15.0) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>*pGradY</em>&nbsp;</td><td>Pointer to array containing Y gradient (SQ15.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>width</em>&nbsp;</td><td>Input width (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>height</em>&nbsp;</td><td>Input height (UQ16.0)</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Assumptions:</b></dt><dd><ul>
<li>The function processes only valid non-border pixels of the input correctly and this results in the output gradients being cropped to have only (<code>width</code> - 2) x (<code>height</code> - 2) valid pixels. This can be avoided by padding input and output borders with meaningful data.</li><li>The first output pixel is obtained by processing the first valid non-border input pixel, causing a shift in the output gradient images with respect to the input image. The shift is one pixel to the left and one pixel to the top. The shift can be avoided by passing the pointer to the second pixel of the second row of the gradient images as the arguments <code>pGradX</code> and <code>pGradY</code> to the function.</li><li>Since the output is cropped, its border pixels do not contain valid data. If the shift is avoided as explained above, the output border pixels are invalid. If the shift is not avoided, two rightmost columns and two bottommost rows of the output gradient images do not contain valid data. See <a class="el" href="filter_shift.html">Output Shift by Filtering Functions</a> for more information.</li><li>The gradient filter has no memory boundary alignment requirements. </li></ul>
</dd></dl>

</div>
</div><p>
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
