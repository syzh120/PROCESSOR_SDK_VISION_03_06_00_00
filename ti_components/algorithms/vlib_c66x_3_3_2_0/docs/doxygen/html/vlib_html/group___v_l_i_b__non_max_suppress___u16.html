<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>VLIB: VLIB_nonMaxSuppress_U16</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>VLIB_nonMaxSuppress_U16</h1><hr><a name="_details"></a><h2>Detailed Description</h2>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l_i_b__non_max_suppress___u16.html#gf3f0a214062a97ec51e01cdcad607088">VLIB_nonMaxSuppress_U16</a> (const uint16_t im[restrict], int32_t w, int32_t h, int32_t filterWidth, uint32_t threshold, uint16_t buffer[restrict], int16_t pixIndex[restrict])</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gf3f0a214062a97ec51e01cdcad607088"></a><!-- doxytag: member="c66/VLIB_nonMaxSuppress_U16.h::VLIB_nonMaxSuppress_U16" ref="gf3f0a214062a97ec51e01cdcad607088" args="(const uint16_t im[restrict], int32_t w, int32_t h, int32_t filterWidth, uint32_t threshold, uint16_t buffer[restrict], int16_t pixIndex[restrict])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t VLIB_nonMaxSuppress_U16           </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&nbsp;</td>
          <td class="paramname"> <em>im</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&nbsp;</td>
          <td class="paramname"> <em>filterWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>buffer</em>[restrict], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&nbsp;</td>
          <td class="paramname"> <em>pixIndex</em>[restrict]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Description</b></dt><dd>This function implements a non-maximum suppression algorithm with programmable filter size. It compares the value of each input pixel against its neighbors. For an output pixel to be "on" (coordinate pair included in the <code>pixIndex</code> list), the input pixel value must be both:<ul>
<li>Greater than or equal to its neighbors</li><li>Greater than the <code>threshold</code> value</li></ul>
</dd></dl>
If the above conditions are not met simultanously, the output coordinate will not be included in the <code>pixIndex</code> list.<p>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>im[]</em>&nbsp;</td><td>Input image (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>w</em>&nbsp;</td><td>Image width (SQ31.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>h</em>&nbsp;</td><td>Image height (SQ31.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>filterWidth</em>&nbsp;</td><td>Filter width (SQ31.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threshold</em>&nbsp;</td><td>Threshold for the Maxima (UQ32.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>buffer[]</em>&nbsp;</td><td>Buffer for internal use (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>pixIndex[]</em>&nbsp;</td><td>List of coordinates of non-maxima locations (SQ15.0)</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Assumptions</b></dt><dd><ul>
<li>The only acceptable values for <code>filterWidth</code> are 3, 5, and 7, representing filter masks sizes 3x3, 5x5, and 7x7, respectively.</li><li>The internal buffer (<code>buffer</code>) size should be at least ((2 * <code>filterWidth</code>) + (<code>w</code> * <code>h</code>))*sizeof(uint16_t) bytes</li><li>The output buffer (<code>pixIndex</code>) size should be (2*w*h+2)*sizeof(uint16_t) bytes</li><li>The format of the output buffer (<code>pixIndex</code>) is as follows:<ul>
<li><code>pixIndex</code>[] = {numPoints, 0, y1, x1, y2, x2, y3, x3, yn, xn}<ul>
<li>where <em>n</em> = numPoints = the number of points contained in the list.</li></ul>
</li></ul>
</li><li>Due the the method of filtering, the output list will not include pixel coordinates which are located within the border of the input image. The number of border pixels is defined by the following equation: border pixels = (filterWidth-1)/2.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Benchmarks:</b></dt><dd>See VLIB_Test_Report.html for cycle and memory information. </dd></dl>

</div>
</div><p>
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
