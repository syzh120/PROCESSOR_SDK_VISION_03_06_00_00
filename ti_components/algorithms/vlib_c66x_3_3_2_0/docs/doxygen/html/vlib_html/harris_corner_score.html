<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>VLIB: Harris Corner Score</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="index.html">VLIB Function Reference</a></div>
<h1><a class="anchor" name="harris_corner_score">Harris Corner Score</a></h1><h2><a class="anchor" name="intro20">
Introduction and Use Cases</a></h2>
Various vision algorithms operate by identifying salient image points and processing their neighborhoods. The Harris Score is a popular measure of saliency. It tends to find corner-like image textures for high Harris scores, which are relatively easy to match between different views or to track in a video sequence. Additionally, extreme negative scores can correspond to edges in an image.<h2><a class="anchor" name="specification20">
Specification</a></h2>
<h3><a class="anchor" name="function20">
Function</a></h3>
Computes the Harris corner score for each pixel in a luma image. As input, the function takes the horizontal and vertical gradients of the image. This gives flexibility to the user in selecting the scale for gradient computations. The score is encoded (compressed) into either 16-bit or 32-bit containers, as explained below in the "Method" section.<h3><a class="anchor" name="variants20">
Variants</a></h3>
This functionality is available in two variants of the output: compressed 16-bit and compressed 32-bit.<h3><a class="anchor" name="input20">
Inputs</a></h3>
<div class="fragment"><pre class="fragment">

    Parameter          Description                                   16-bit      32-bit
    -------------------------------------------------------------------------------------
    *gradX    Horizontal gradient of the input luma image           (SQ15.0)    (SQ15.0)
    *gradY    Vertical gradient of the input luma image             (SQ15.0)    (SQ15.0)
     width    Image width                                           (SQ31.0)    (SQ31.0)
     height   Image height                                          (SQ31.0)    (SQ31.0)
    *outm     Harris (cornerness) score                          exp=6 man=10  exp=5 man=27
     k        Sensitivity parameter                                 (SQ0.15)    (SQ0.15)
    *buffer   Scratch buffer                                        (UQ8.0)     (UQ8.0)
   </pre></div><h3><a class="anchor" name="outputs20">
Outputs</a></h3>
<div class="fragment"><pre class="fragment">
    Returns VLIB Error Status
</pre></div> <h3><a class="anchor" name="method20">
Method</a></h3>
For each pixel, the following equations together compute the 2x2 gradient covariance matrix M, where the summations are over 7x7 pixel neighborhoods: <div class="fragment"><pre class="fragment">

    M(1,1) = sum(gradX)^2
    M(1,2) = M(2,1) = sum(gradX x gradY)
    M(2,2) = sum(gradY)^2
    </pre></div> The cornerness score is defined as in the following equation, where k is a tunable sensitivity parameter, typically around 0.04. The underlying score computation generates a signed 47 bit result, which is internally computed using signed 64-bit data types (int64_t). <div class="fragment"><pre class="fragment">
    Score (signed 47-bit)   = det(M) - k * trace(M)^2
</pre></div> To save memory storing this data, the algorithm compresses this output to either 16 bits or 32 bits, depending on the variant of the kernel used, using an approximation of the binary log. Order relationships between different score values is maintained in this format, up to the quantization limits. Such a format is superior compared to simple rounding in therms of quantization errors as the below format preserves maximum number of bits from the original score. The exact format of Harris score stored in outm[] is as follows: <div class="fragment"><pre class="fragment">

    Harris score 16-bit format:    Exponent = 7bit, Mantissa =  9 bit (eg. EEEE EEEM MMMM MMMMb)
    Harris score 32-bit format:    Exponent = 6bit, Mantissa = 26 bit (eg. EEEE EEMM MMMM MMMM MMMM MMMM MMMM MMMMb)
                                                                           where E: Exponent bits, M: Mantissa bits
    </pre></div> The exponent corresponds to the location of the leading non-redundant sign-bit in the score (where the lsb is location = 1, and msb is location = 64). The mantissa contains the relevant bits (9 bits for the 16-bit Harris score, and 26 bits for the 32-bit Harris score) starting from the leading non-redundant sign-bit.<p>
For 16-bit Harris score, the exponent is 0 if the absolute value of the score is less than 2^9. If the absolute value of the score is greater, (lmb - 9) is stored in the exponent for positive scores, and -(lmb - 9) is stored in the exponent for negative scores. For 32-bit Harris scores, the exponent is 0 if the absolute value of the score is less than 2^26. If the absolute value of the score is greater than 2^26, (lmb - 26) is stored in the exponentfor positive scores, and -(lmb - 26) is stored in the exponent for negative scores. For example, a signed score of 571717286 (= 0010 0010 0001 0011 1011 0110 1010 0110b) will be encoded by the 32-bit kernel as = (30-26)*2^26 + (571717286)&gt;&gt;(30-26)=304167786.<h3><a class="anchor" name="apis20">
APIS</a></h3>
<ul>
<li><a class="el" href="group___v_l_i_b__harris_score__7x7.html">VLIB_harrisScore_7x7</a></li><li><a class="el" href="group___v_l_i_b__harris_score__7x7___s32.html">VLIB_harrisScore_7x7_S32</a></li></ul>
<h2><a class="anchor" name="notes20">
Notes</a></h2>
<ul>
<li>Garbage may be written in the output margins, which are 3 pixels wide on each side. If the input gradient also has a margin of 1 pixel, then there is an overall output margin of 4 pixels.</li><li>This method uses a scratch buffer which must be at least 96 * <code>width</code> bytes.</li></ul>
<h2><a class="anchor" name="references20">
References</a></h2>
<ol type=1>
<li><em> A Combined Corner and Edge Detector </em> by Chris Harris and Mike Stephens Plessey Research Roke Manor, UK from "Proceedings of The Fourth Alvey Vision Conference, Manchester", pp 147-151, 1988</li><li><a href="http://www.csse.uwa.edu.au/~pk/research/matlabfns/Spatial/harris.m">http://www.csse.uwa.edu.au/~pk/research/matlabfns/Spatial/harris.m</a> </li></ol>
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
