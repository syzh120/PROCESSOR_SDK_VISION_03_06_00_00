<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>VLIB: Connected Components Labeling</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="index.html">VLIB Function Reference</a></div>
<h1><a class="anchor" name="connected_components_labeling">Connected Components Labeling</a></h1><h2><a class="anchor" name="intro11">
Introduction and Use Cases</a></h2>
Segmentation algorithms are often used to separate an image into salient (foreground) and non-salient (background) pixels; for example, <a class="el" href="group___v_l_i_b__subtract_background_s16.html">VLIB_subtractBackgroundS16</a>. These methods typically produce a binary image that identifies each pixel as belonging either to the foreground or background. The connected components labeling algorithm examines the binary image, groups foreground pixels that have other foreground pixels as 4- or 8-connected neighbors, and labels discrete groupings as components. Once accomplished, component properties can be measured and used to extract foreground information.<h2><a class="anchor" name="specification11">
Specification</a></h2>
<h3><a class="anchor" name="function11">
Function</a></h3>
The primary function for grouping and labeling foreground components or blobs in a binary image is <a class="el" href="group___v_l_i_b___connected___components___labeling.html#ga22e593e5879e9f5747e6a3f34c2c0e8">VLIB_createConnectedComponentsList</a>. After the handle is created and initialized by way of <a class="el" href="group___v_l_i_b___connected___components___labeling.html#g9bbfbe07381bebfb513875e7e9522180">VLIB_initConnectedComponentsList</a>, a 32-bit packed binary image should be supplied as input to the function such that each bit corresponds to a pixel location. For example, the most significant bit in the first 32-bit word represents the top-left corner of the binary image. By passing the handle to support functions, such as <a class="el" href="group___v_l_i_b___connected___components___labeling.html#g03a8f706b96db00b37ec9e14b35a04db">VLIB_getCCFeatures</a>, properties about the foreground regions in the image can be extracted.<p>
The support function <a class="el" href="group___v_l_i_b___connected___components___labeling.html#gaccfb29ff7e6fb7cfaf2ba4e4bd8efa0">VLIB_createCCMap8Bit</a> produces an 8-bit 2D map that labels every pixel in the image with its corresponding blob ID. Pixels associated with the background are all given ID = 0. Other support functions that extract blob information from the list are: <a class="el" href="group___v_l_i_b___connected___components___labeling.html#g6f073b44bc492861a353bfc05ed9efa2">VLIB_getNumCCs</a> and <a class="el" href="group___v_l_i_b___connected___components___labeling.html#g03a8f706b96db00b37ec9e14b35a04db">VLIB_getCCFeatures</a>. The former returns the number of connected components in the list, while the latter reveals features of the component as defined by the follow structure: <div class="fragment"><pre class="fragment">
    typedef struct
    {   S32 area;
        S32 xsum;
        S32 ysum;
        S32 xmin;
        S32 ymin;
        S32 xmax;
        S32 ymax;
        S32 seedx;
        S32 seedy;
    } VLIB_CC;
     </pre></div> The pixel defined by a components centroid is not guaranteed to be a member of the component. Thus, a guaranteed point in the connected component namely (seedx, seedy) is provided.<p>
Additional features will be added to the structure as required. More support functions are also planned for future releases.<h3><a class="anchor" name="apis11">
APIS</a></h3>
<ul>
<li><a class="el" href="group___v_l_i_b___connected___components___labeling.html#ge838143c00d8162361221ed291755864">VLIB_calcConnectedComponentsMaxBufferSize</a></li><li><a class="el" href="group___v_l_i_b___connected___components___labeling.html#g9bbfbe07381bebfb513875e7e9522180">VLIB_initConnectedComponentsList</a></li><li><a class="el" href="group___v_l_i_b___connected___components___labeling.html#ga22e593e5879e9f5747e6a3f34c2c0e8">VLIB_createConnectedComponentsList</a></li><li><a class="el" href="group___v_l_i_b___connected___components___labeling.html#g6f073b44bc492861a353bfc05ed9efa2">VLIB_getNumCCs</a></li><li><a class="el" href="group___v_l_i_b___connected___components___labeling.html#g03a8f706b96db00b37ec9e14b35a04db">VLIB_getCCFeatures</a></li><li><a class="el" href="group___v_l_i_b___connected___components___labeling.html#gaccfb29ff7e6fb7cfaf2ba4e4bd8efa0">VLIB_createCCMap8Bit</a></li></ul>
<h2><a class="anchor" name="notes11">
Notes</a></h2>
The amount of memory used by <a class="el" href="group___v_l_i_b___connected___components___labeling.html#ga22e593e5879e9f5747e6a3f34c2c0e8">VLIB_createConnectedComponentsList</a> depends on the binary image. To provide a buffer with sufficient size to accommodate any binary image, use the support function <a class="el" href="group___v_l_i_b___connected___components___labeling.html#ge838143c00d8162361221ed291755864">VLIB_calcConnectedComponentsMaxBufferSize</a> to estimate the upper bound. The function returns the maximum required bytes to support the pathological arrangement of foreground pixels in the input image, which is generally very large.<p>
When the binary image is preprocessed by morphological operations like erode or dilate that remove isolated pixels and small blobs, the actual upper bound needed is much smaller than the calculated maximum bytes, generally by a factor of 2 to 4, but perhaps even more. Because the amount suggested will generally require an external memory buffer to store the list of connected components, enabling the cache is highly recommended.<p>
If the buffer is statically allocated only once, the initialization function <a class="el" href="group___v_l_i_b___connected___components___labeling.html#g9bbfbe07381bebfb513875e7e9522180">VLIB_initConnectedComponentsList</a> only needs to be called once prior to calling <a class="el" href="group___v_l_i_b___connected___components___labeling.html#ga22e593e5879e9f5747e6a3f34c2c0e8">VLIB_createConnectedComponentsList</a>. However, if the allocated memory buffer address changes, that is dynamically allocated within an application, it must be called before each call to <a class="el" href="group___v_l_i_b___connected___components___labeling.html#ga22e593e5879e9f5747e6a3f34c2c0e8">VLIB_createConnectedComponentsList</a>. These functions are not re-entrant.<h2><a class="anchor" name="performance11">
Performance</a></h2>
<a class="el" href="group___v_l_i_b___connected___components___labeling.html#ga22e593e5879e9f5747e6a3f34c2c0e8">VLIB_createConnectedComponentsList</a> and <a class="el" href="group___v_l_i_b___connected___components___labeling.html#gaccfb29ff7e6fb7cfaf2ba4e4bd8efa0">VLIB_createCCMap8Bit</a> are the only computation intensive APIs for connected components; the others simply make calls to internal structures. DSP performance is correlated with the relative size and number of connected components extracted from the 32-bit packed binary foreground mask. That is, larger and more numerous components will consume more DSP cycles and memory than smaller and fewer components.<p>
Allocating buffers with memory sufficient to handle the worst case scenario given image resolution and size of components is recommended. This can be computed using <a class="el" href="group___v_l_i_b___connected___components___labeling.html#ge838143c00d8162361221ed291755864">VLIB_calcConnectedComponentsMaxBufferSize</a>. <a class="el" href="group___v_l_i_b___connected___components___labeling.html#ga22e593e5879e9f5747e6a3f34c2c0e8">VLIB_createConnectedComponentsList</a> performance ranges from 1.1 cycles per input pixel to 5.2 cycles/pixel; likewise, <a class="el" href="group___v_l_i_b___connected___components___labeling.html#gaccfb29ff7e6fb7cfaf2ba4e4bd8efa0">VLIB_createCCMap8Bit</a> ranges from 3.0 to 8.0 cycles/pixel. The algorithm is frame-based and highly image dependent. The above performance estimates are average estimates for real use cases and worst case measurements may be much higher.<h2><a class="anchor" name="references11">
References</a></h2>
<ol type=1>
<li><em> Robot Vision </em>, Horn, MIT Press, 1986, pp. 69-71. </li></ol>
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
