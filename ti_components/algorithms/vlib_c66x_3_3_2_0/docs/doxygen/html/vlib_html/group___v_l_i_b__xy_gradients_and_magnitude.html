<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>VLIB: VLIB_xyGradientsAndMagnitude</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>VLIB_xyGradientsAndMagnitude</h1><hr><a name="_details"></a><h2>Detailed Description</h2>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l_i_b__xy_gradients_and_magnitude.html#gfdeb12d990b423dfcaa8064638c7735f">VLIB_xyGradientsAndMagnitude</a> (const uint8_t *restrict pIn, int16_t *restrict pGradX, int16_t *restrict pGradY, int16_t *restrict pMag, uint16_t width, uint16_t height)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="gfdeb12d990b423dfcaa8064638c7735f"></a><!-- doxytag: member="c66/VLIB_xyGradientsAndMagnitude.h::VLIB_xyGradientsAndMagnitude" ref="gfdeb12d990b423dfcaa8064638c7735f" args="(const uint8_t *restrict pIn, int16_t *restrict pGradX, int16_t *restrict pGradY, int16_t *restrict pMag, uint16_t width, uint16_t height)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t VLIB_xyGradientsAndMagnitude           </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *restrict&nbsp;</td>
          <td class="paramname"> <em>pIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *restrict&nbsp;</td>
          <td class="paramname"> <em>pGradX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *restrict&nbsp;</td>
          <td class="paramname"> <em>pGradY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t *restrict&nbsp;</td>
          <td class="paramname"> <em>pMag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>height</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Description:</b></dt><dd>For each pixel in the image, the 2nd step in Canny edge detection extracts the horizontal and vertical 1st order gradients along with an approximation of the gradient magnitude. Gradients are 2D vectors which point in the direction of the greatest rate of change, in this case, in intensity. This function extracts the 2D gradient vector coordinates as well as magnitude.</dd></dl>
<dl class="user" compact><dt><b>Method:</b></dt><dd>The first order 3x3 gradient filter calculates the first derivative in both the horizontal and vertical directions, Gx and Gy, respectively. So for the image pixel I(x,y), we calculate the gradients and approximate the magnitude as shown in the following equations:</dd></dl>
<div class="fragment"><pre class="fragment">

    Gx = I(x+1,y) - I(x-1,y)
    Gy = I(x,y+1) - I(x,y-1)
    Gmag = (|Gx| + |Gy|)

    Gx, Gy and Gmag are all signed, 16-bit values.
   </pre></div><p>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>*pIn</em>&nbsp;</td><td>Pointer to array containing input image (UQ8.0) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>*pGradX</em>&nbsp;</td><td>Pointer to array containing X gradient (SQ15.0) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>*pGradY</em>&nbsp;</td><td>Pointer to array containing Y gradient (SQ15.0) </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>*pMag</em>&nbsp;</td><td>Pointer to array containing magnitude (SQ15.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>width</em>&nbsp;</td><td>Input width (UQ16.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>height</em>&nbsp;</td><td>Input height (UQ16.0)</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Assumptions:</b></dt><dd><ul>
<li>When this is used in the <a class="el" href="group___v_l_i_b___canny___edge___detection.html">VLIB_Canny_Edge_Detection</a> function, the <a class="el" href="group___v_l_i_b___canny___edge___detection.html#gbadb02fc6fc81c924cd7f81ee02237b4">VLIB_conv_7x7_i8_c8s</a> function performs a 7x7 Gaussian filtering, which creates a 3-pixel border around the image that contains invalid data. In the interest of performance, the gradient filter processes these border pixels, but later stages will discount them appropriately.</li><li>The function processes only valid non-border pixels of the input correctly and this results in the output gradient and magnitude images being cropped to have only (<code>width</code> - 2) x (<code>height</code> - 2) valid pixels. This can be avoided by padding input and output borders with meaningful data.</li><li>The first output pixel is obtained by processing the first valid non-border input pixel, causing a shift in the output gradient and magnitude images with respect to the input image. The shift is one pixel to the left and one pixel to the top. The shift can be avoided by passing the pointer to the second pixel of the second row of the output images as the arguments <code>pGradX</code>, <code>pGradY</code> and <code>pMag</code> to the function.</li><li>Since the output is cropped, its border pixels do not contain valid data. If the shift is avoided as explained above, the output border pixels are invalid. If the shift is not avoided, two rightmost columns and two bottommost rows of the output gradient and magnitude images do not contain valid data. See <a class="el" href="filter_shift.html">Output Shift by Filtering Functions</a> for more information.</li><li>The gradient filter has no memory boundary alignment requirements. </li></ul>
</dd></dl>

</div>
</div><p>
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
