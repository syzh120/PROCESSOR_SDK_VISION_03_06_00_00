<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>VLIB: VLIB_insertLumaIntoYUYV</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<table width=100%>
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border=0 src="tilogo.gif"></a></td>
  <td bgcolor="red"><img src="titagline.gif"></td>
</tr>
</table>
<!-- Generated by Doxygen 1.5.1-p1 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="modules.html"><span>Modules</span></a></li>
    <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
  </ul></div>
<h1>VLIB_insertLumaIntoYUYV</h1><hr><a name="_details"></a><h2>Detailed Description</h2>

<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___v_l_i_b__insert_luma_into_y_u_y_v.html#g839ef912bdb4d9de5f46e9caafdb0758">VLIB_insertLumaIntoYUYV</a> (const uint8_t *restrict pInY, uint16_t inCols, uint16_t inPitch, uint16_t inRows, uint8_t *restrict pOutYUYV)</td></tr>

</table>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="g839ef912bdb4d9de5f46e9caafdb0758"></a><!-- doxytag: member="c66/VLIB_insertLumaIntoYUYV.h::VLIB_insertLumaIntoYUYV" ref="g839ef912bdb4d9de5f46e9caafdb0758" args="(const uint8_t *restrict pInY, uint16_t inCols, uint16_t inPitch, uint16_t inRows, uint8_t *restrict pOutYUYV)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t VLIB_insertLumaIntoYUYV           </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *restrict&nbsp;</td>
          <td class="paramname"> <em>pInY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>inCols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>inPitch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>inRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *restrict&nbsp;</td>
          <td class="paramname"> <em>pOutYUYV</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="user" compact><dt><b>Introduction and Use Cases:</b></dt><dd>When the image data is stored in the YUV422 format but the processing needs to be done on its luminance component only, it is often desirable to extract the Y component and store it in a separate buffer. This is particularly useful when data needs to be contiguous. After the luma-only processing is complete, it may be desirable to reinsert the modified luma data back into the original YUV422 image.</dd></dl>
<dl class="user" compact><dt><b>Description:</b></dt><dd>This function overwrites the luminance data of the pOutYUYV interleaved image using the the luma-only pInYbuffer data. The chrominance components of the output image are unaffected.</dd></dl>
<dl class="user" compact><dt><b></b></dt><dd></dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>*pInY</em>&nbsp;</td><td>Luma-only input image (UQ8.0) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inCols</em>&nbsp;</td><td>Width of input image (in luma pixels) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inPitch</em>&nbsp;</td><td>Pitch of pOutYUYV image (in luma pixels) </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inRows</em>&nbsp;</td><td>Height of input image (in luma pixels) </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>*pOutYUYV</em>&nbsp;</td><td>Output YUV422 image (UQ8.0)</td></tr>
  </table>
</dl>
<dl class="user" compact><dt><b>Assumptions</b></dt><dd><ul>
<li>All arrays should be 64-bit aligned.</li><li>inCols should be a multiple of 16, and greater than 0</li><li>inPitch should be a multiple of 4, and &gt;= inCols</li><li>inPitch applies to the number of luma pixels per row of the pOutYUYV buffer, it doesn't apply to the pInY buffer. The pitch of the pInY buffer is assumed to be the same as inCols.</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Implementation Notes:</b></dt><dd><ul>
<li>Internally, there are 2 modes:<ul>
<li>Mode 1: Most efficient mode is when inPitch == inCols</li><li>Mode 2: Kernel supports when inPitch &gt; inCols, but less performance</li></ul>
</li></ul>
</dd></dl>
<dl class="user" compact><dt><b>Benchmarks:</b></dt><dd>See VLIB_Test_Report.html for cycle and memory information. </dd></dl>

</div>
</div><p>
<hr size="1"><small>
Copyright  2018, Texas Instruments Incorporated</small>
</body>
</html>
